=====================
1736984296392-create-user.ts
db/migrations/1736984296392-create-user.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateUser1736984296392 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TYPE user_role AS ENUM ('ADMIN', 'MANAGER', 'EMPLOYEE');
            
            CREATE TABLE IF NOT EXISTS "users" (
                "id" SERIAL PRIMARY KEY,
                "email" VARCHAR(255) UNIQUE NOT NULL,
                "password" VARCHAR(255) NOT NULL,
                "role" user_role NOT NULL,
                "created_at" timestamp NOT NULL DEFAULT 'now()',
                "updated_at" timestamp NOT NULL DEFAULT 'now()',
                "deleted_at" timestamp
            );
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "users";
        `);
    }
}

=====================


=====================
1736984315673-create-sessions.ts
db/migrations/1736984315673-create-sessions.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateSessions1736984315673 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TABLE IF NOT EXISTS "sessions" (
                "id" SERIAL PRIMARY KEY,
                "user_id" INTEGER NOT NULL,
                "access_token" VARCHAR(255) UNIQUE NOT NULL,
                "refresh_token" VARCHAR(255) UNIQUE NOT NULL,
                "access_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
                "refresh_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
                "user_agent" VARCHAR(255),
                "latitude" VARCHAR(50),
                "longitude" VARCHAR(50),
                "ip_address" VARCHAR(50),
                "created_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY ("user_id") REFERENCES "users" ("id")
            );
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "sessions";
        `);
    }
}

=====================


=====================
1736984319024-create-rbac.ts
db/migrations/1736984319024-create-rbac.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateRbac1736984319024 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TABLE IF NOT EXISTS "resources" (
                "id" TEXT PRIMARY KEY
            );
            
            CREATE TABLE IF NOT EXISTS "actions" (
                "id" TEXT PRIMARY KEY
            );
            
            CREATE TABLE IF NOT EXISTS "role_resource_actions" (
                "role" user_role NOT NULL,
                "resource" TEXT NOT NULL REFERENCES "resources"(id),
                "action" TEXT NOT NULL REFERENCES "actions"(id)
            );
            
            CREATE UNIQUE INDEX rra_unique_idx ON "role_resource_actions"("role", "resource", "action");
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "role_resource_actions";
            DROP TABLE IF EXISTS "actions";
            DROP TABLE IF EXISTS "resources";
            DROP TYPE IF EXISTS action_type;
            DROP TYPE IF EXISTS resource_type;
            DROP TYPE IF EXISTS user_role;
        `);
    }
}

=====================


=====================
package-lock.json
package-lock.json
=====================

"package-lock.json" is not a text file (MIME type: application/json)

=====================


=====================
package.json
package.json
=====================

"package.json" is not a text file (MIME type: application/json)

=====================


=====================
auth.proto
proto/auth.proto
=====================
// proto/auth.proto
syntax = "proto3";

package auth;

service AuthService {
  rpc FindUserById(FindByIdRequest) returns (User);
  rpc AuthenticateAccessToken(AuthenticateAccessTokenRequest) returns (User);
  rpc FindRolePermission(FindRolePermissionRequest) returns (RolePermission);
}

message FindByIdRequest {
  int64 id = 1;
}

message AuthenticateAccessTokenRequest {
  string access_token = 1;
}

message FindRolePermissionRequest {
  string role = 1;
}

message User {
  int64 id = 1;
  string email = 2;
  string role = 3;
  string created_at = 4;
  string updated_at = 5;
}

message Permission {
  string resource = 1;
  string action = 2;
}

message RolePermission {
  string role = 1;
  repeated Permission permissions = 2;
}
=====================


=====================
database.ts
src/config/database.ts
=====================
import { DataSourceOptions } from 'typeorm';
import { Config } from './index';

export const databaseConfig: DataSourceOptions = {
    type: 'postgres',
    url: Config.DATABASE_URL,
    entities: ['src/domain/entities/*.entity.ts'],
    migrations: ['db/migrations/*.ts'],
    migrationsTableName: 'schema_migrations',
    synchronize: false,
    logging: true
};
=====================


=====================
index.ts
src/config/index.ts
=====================
import dotenv from 'dotenv';

dotenv.config();

export class Config {
    static get NODE_ENV(): string {
        return process.env.NODE_ENV || 'development';
    }

    static get DATABASE_URL(): string {
        return process.env.DATABASE_URL || 'postgresql://auth_user:auth123@localhost:5432/auth_db';
    }

    static get REDIS_URL(): string {
        return process.env.REDIS_URL || 'redis://localhost:6379';
    }

    static get HTTP_PORT(): number {
        return parseInt(process.env.HTTP_PORT || '3000');
    }

    static get GRPC_PORT(): number {
        return parseInt(process.env.GRPC_PORT || '50051');
    }

    static get JWT_SECRET(): string {
        return process.env.JWT_SECRET || 'your-secret-key';
    }
}
=====================


=====================
redis.ts
src/config/redis.ts
=====================
import Redis from 'ioredis';
import { config } from 'dotenv';

config();

export const redis = new Redis({
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || '6379'),
});
=====================


=====================
create-migration.ts
src/console/create-migration.ts
=====================
// src/console/create-migration.ts
import { Command } from 'commander';
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { Logger } from '@/utils/logger';

export const createMigrationCommand = new Command('create:migration')
    .description('Create a new migration file')
    .argument('<name>', 'migration name')
    .action((name: string) => {
        try {
            // Generate timestamp
            const timestamp = Date.now();

            // Convert name to PascalCase
            const className = name
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join('');

            const migrationContent = `import { MigrationInterface, QueryRunner } from "typeorm";

export class ${className}${timestamp} implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(\`
            -- Write your UP migration SQL here
        \`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(\`
            -- Write your DOWN migration SQL here
        \`);
    }
}
`;

            const migrationsDir = join(process.cwd(), 'db', 'migrations');
            mkdirSync(migrationsDir, { recursive: true });

            const fileName = `${timestamp}-${name}.ts`;
            const filePath = join(migrationsDir, fileName);

            writeFileSync(filePath, migrationContent);
            Logger.info(`Created migration file: ${fileName}`);

            // Tambahkan instruksi untuk pengguna
            Logger.info('\nNext steps:');
            Logger.info('1. Open the generated migration file');
            Logger.info('2. Replace the SQL placeholders with your actual migration SQL');
            Logger.info('3. Run the migration with: npm run migrate');
        } catch (error) {
            Logger.error('Failed to create migration:', error);
            process.exit(1);
        }
    });
=====================


=====================
migrate-rbac.ts
src/console/migrate-rbac.ts
=====================
// src/console/migrate-rbac.ts
import { Command } from 'commander';
import { container } from 'tsyringe';
import { Logger } from '@/utils/logger';
import { Role, DEFAULT_RESOURCES, DEFAULT_ACTIONS } from '@/utils/constants';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { DataSource } from 'typeorm';
import { Config } from '@/config';
import Redis from 'ioredis';
import { setupContainer } from './server';

export const migrateRBACCommand = new Command('migrate:rbac')
    .description('Migrate RBAC default permissions')
    .action(async () => {
        try {
            Logger.info('Starting RBAC migration...');

            // Initialize database connection
            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                synchronize: false,
                logging: true
            });

            await dataSource.initialize();
            Logger.info('Database connected successfully');

            // Initialize Redis
            const redis = new Redis(Config.REDIS_URL);
            Logger.info('Redis connected successfully');

            // Setup dependency injection
            await setupContainer(dataSource, redis);

            // Resolve RBACRepository
            const rbacRepo = container.resolve<RBACRepository>('RBACRepository');

            // Create resources
            Logger.info('Creating resources...');
            for (const resource of Object.values(DEFAULT_RESOURCES)) {
                await rbacRepo.createResource(resource);
                Logger.info(`Created resource: ${resource}`);
            }

            // Create actions
            Logger.info('Creating actions...');
            for (const action of Object.values(DEFAULT_ACTIONS)) {
                await rbacRepo.createAction(action);
                Logger.info(`Created action: ${action}`);
            }

            // Create default permissions
            Logger.info('Creating role-resource-action mappings...');

            // Admin permissions (all access)
            for (const resource of Object.values(DEFAULT_RESOURCES)) {
                for (const action of Object.values(DEFAULT_ACTIONS)) {
                    await rbacRepo.createRoleResourceAction(Role.ADMIN, resource, action);
                    Logger.info(`Created permission: ${Role.ADMIN} - ${resource} - ${action}`);
                }
            }

            // Manager permissions
            const managerPermissions = [
                { resource: DEFAULT_RESOURCES.EMPLOYEE, action: DEFAULT_ACTIONS.READ },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.APPROVE },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.REJECT },
                { resource: DEFAULT_RESOURCES.REPORT, action: DEFAULT_ACTIONS.READ }
            ];

            for (const perm of managerPermissions) {
                await rbacRepo.createRoleResourceAction(Role.MANAGER, perm.resource, perm.action);
                Logger.info(`Created permission: ${Role.MANAGER} - ${perm.resource} - ${perm.action}`);
            }

            // Employee permissions
            const employeePermissions = [
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.SUBMIT },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ }
            ];

            for (const perm of employeePermissions) {
                await rbacRepo.createRoleResourceAction(Role.EMPLOYEE, perm.resource, perm.action);
                Logger.info(`Created permission: ${Role.EMPLOYEE} - ${perm.resource} - ${perm.action}`);
            }

            Logger.info('RBAC migration completed successfully!');

            // Cleanup connections
            await redis.quit();
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('RBAC migration failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
migrate.ts
src/console/migrate.ts
=====================
// src/console/migrate.ts
import { Command } from 'commander';
import { DataSource } from 'typeorm';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';

export const migrateCommand = new Command('migrate')
    .description('Database migration command')
    .option('--step <number>', 'maximum migration steps', '0')
    .option('--direction <string>', 'migration direction (up/down)', 'up')
    .action(async (options) => {
        try {
            const direction = options.direction;
            const step = parseInt(options.step);

            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                migrations: ['db/migrations/*.ts'],
                migrationsTableName: 'schema_migrations'
            });

            await dataSource.initialize();
            Logger.info('Database connected');

            if (direction === 'down') {
                if (step > 0) {
                    Logger.info(`Rolling back ${step} migration(s)...`);
                    for (let i = 0; i < step; i++) {
                        await dataSource.undoLastMigration();
                    }
                } else {
                    Logger.info('Rolling back last migration...');
                    await dataSource.undoLastMigration();
                }
            } else {
                Logger.info('Running pending migrations...');
                await dataSource.runMigrations();
            }

            Logger.info('Migrations completed successfully!');
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('Migration failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
server.ts
src/console/server.ts
=====================
// src/console/server.ts
import express from 'express';
import { createServer } from 'http';
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import Redis from 'ioredis';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';
import { setupRoutes } from '@/delivery/http/routes';
// import { setupGraphQL } from '@/delivery/graphql';
import { GrpcServer } from '@/delivery/grpc/server';

// Repositories
import { UserRepositoryImpl } from '@/repository/user.repository';
import { SessionRepositoryImpl } from '@/repository/session.repository';
import { RBACRepositoryImpl } from '@/repository/rbac.repository';

// Use Cases
import { LoginUseCase } from '@/usecase/auth/login.usecase';
import { ValidateTokenUseCase } from '@/usecase/auth/validate-token.usecase';
import {LogoutUseCase} from "@/usecase/auth/logout.usecase";
import {RefreshTokenUseCase} from "@/usecase/auth/refresh-token.usecase";
import {SessionRepository} from "@/domain/repositories/session.repository";
import {UserRepository} from "@/domain/repositories/user.repository";
import {RBACRepository} from "@/domain/repositories/rbac.repository";

export class Server {
    private httpServer: express.Application;
    private grpcServer: GrpcServer;
    private dataSource!: DataSource;
    private redis!: Redis;
    private logger: typeof Logger;

    constructor() {
        this.httpServer = express();
        this.grpcServer = new GrpcServer();
        this.logger = Logger;
    }

    async initialize(): Promise<void> {
        await this.setupDatabase();
        await this.setupRedis();
        await setupContainer(this.dataSource, this.redis); // Use the shared setup function
        // await this.setupDependencyInjection();
    }

    private async setupDatabase(): Promise<void> {
        this.dataSource = new DataSource({
            type: 'postgres',
            url: Config.DATABASE_URL,
            entities: ['src/domain/entities/*.entity.ts'],
            synchronize: false,
            logging: true
        });

        await this.dataSource.initialize();
        this.logger.info('Database connected successfully');
    }

    private async setupRedis(): Promise<void> {
        this.redis = new Redis(Config.REDIS_URL);
        this.logger.info('Redis connected successfully');
    }

    private async setupDependencyInjection(): Promise<void> {
        // Register instances
        container.registerInstance('DataSource', this.dataSource);
        container.registerInstance('Redis', this.redis);
        container.registerInstance('Logger', this.logger);

        // Register repositories
        container.registerSingleton('UserRepository', UserRepositoryImpl);
        container.registerSingleton('SessionRepository', SessionRepositoryImpl);
        container.registerSingleton('RBACRepository', RBACRepositoryImpl);

        // Debug log
        console.log('UserRepository registered:', container.isRegistered('UserRepository'));

        // Register use cases
        container.registerSingleton(LoginUseCase);
        container.registerSingleton(ValidateTokenUseCase);
    }

    private async setupGrpc(): Promise<void> {
        await this.grpcServer.start();
    }

    async start(): Promise<void> {
        await this.initialize();

        // Setup delivery methods
        await Promise.all([
            this.setupHttp(),
            // this.setupGraphQL(),
            this.setupGrpc()
        ]);

        this.setupGracefulShutdown();
    }

    private async setupHttp(): Promise<void> {
        const httpPort = Config.HTTP_PORT;

        this.httpServer.use(express.json());
        setupRoutes(this.httpServer);

        return new Promise((resolve) => {
            const server = this.httpServer.listen(httpPort, () => {
                this.logger.info(`HTTP Server running on port ${httpPort}`);
                resolve();
            });

            // HTTP Graceful shutdown
            process.on('SIGTERM', () => {
                this.logger.info('SIGTERM received. Shutting down HTTP server...');
                server.close(() => {
                    this.logger.info('HTTP server closed');
                });
            });
        });
    }

    private setupGracefulShutdown(): void {
        const shutdown = async () => {
            this.logger.info('Shutting down...');

            try {
                await this.redis.quit();
                await this.dataSource.destroy();
                this.logger.info('Connections closed');
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during shutdown:', error);
                process.exit(1);
            }
        };

        process.on('SIGTERM', shutdown);
        process.on('SIGINT', shutdown);
    }
}

export async function setupContainer(dataSource: DataSource, redis: Redis): Promise<void> {
    // Reset container
    container.reset();

    // Register instances
    container.registerInstance('DataSource', dataSource);
    container.registerInstance('Redis', redis);
    container.registerInstance('Logger', Logger);

    // Register repositories as singletons
    container.registerSingleton<SessionRepository>('SessionRepository', SessionRepositoryImpl);
    container.registerSingleton<UserRepository>('UserRepository', UserRepositoryImpl);
    container.registerSingleton<RBACRepository>('RBACRepository', RBACRepositoryImpl);

    // Register use cases as singletons
    container.registerSingleton(ValidateTokenUseCase);
    container.registerSingleton(LoginUseCase);
    container.registerSingleton(LogoutUseCase);
    container.registerSingleton(RefreshTokenUseCase);

    // Debug logs
    console.log('Container setup completed. Registrations:', {
        dataSource: container.isRegistered('DataSource'),
        redis: container.isRegistered('Redis'),
        sessionRepo: container.isRegistered('SessionRepository'),
        validateTokenUseCase: container.isRegistered(ValidateTokenUseCase)
    });
}
=====================


=====================
user.seeder.ts
src/console/user.seeder.ts
=====================
// src/console/user.seeder.ts
import 'reflect-metadata'; // Tambahkan ini di baris paling atas
import { Command } from 'commander';
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';
import { Role } from '@/utils/constants';
import { UserRepository } from '@/domain/repositories/user.repository';
import { UserRepositoryImpl } from '@/repository/user.repository';
import { User } from '@/domain/entities/user.entity';
import bcrypt from 'bcrypt';
import { setupContainer } from './server';
import Redis from 'ioredis';

export const userSeederCommand = new Command('seed:user')
    .description('Seed default users for testing')
    .action(async () => {
        console.log('userSeederCommand is running...'); // Tambahkan ini
        try {
            Logger.info('Starting user seeder...');

            // Initialize database connection
            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                synchronize: false,
                logging: true
            });

            await dataSource.initialize();
            Logger.info('Database connected successfully');

            // Initialize Redis
            const redis = new Redis(Config.REDIS_URL);
            Logger.info('Redis connected successfully');

            // Setup dependency injection
            await setupContainer(dataSource, redis);

            // Resolve UserRepository
            const userRepo = container.resolve<UserRepository>('UserRepository');

            // Define users to seed
            const usersToSeed = [
                {
                    email: 'admin@example.com',
                    password: 'password123',
                    role: Role.ADMIN
                },
                {
                    email: 'manager@example.com',
                    password: 'password123',
                    role: Role.MANAGER
                },
                {
                    email: 'employee@example.com',
                    password: 'password123',
                    role: Role.EMPLOYEE
                }
            ];

            // Seed users
            for (const userData of usersToSeed) {
                // const hashedPassword = await bcrypt.hash(userData.password, 10);
                const user = new User();
                user.email = userData.email;
                user.password = userData.password;
                user.role = userData.role;

                try {
                    await userRepo.create(user);
                    Logger.info(`Seeded user: ${userData.email} with role: ${userData.role}`);
                } catch (error) {
                    Logger.warn(`User ${userData.email} might already exist:`, error);
                }
            }

            Logger.info('User seeder completed successfully!');

            // Cleanup connections
            await redis.quit();
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('User seeder failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
auth.handler.ts
src/delivery/grpc/handlers/auth.handler.ts
=====================
// src/delivery/grpc/handlers/auth.handler.ts
import { ServerUnaryCall, sendUnaryData } from '@grpc/grpc-js';
import {inject, injectable} from 'tsyringe';
import { ValidateTokenUseCase } from '@/usecase/auth/validate-token.usecase';
import { UserRepository } from '@/domain/repositories/user.repository';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { Logger } from '@/utils/logger';
import { EnumHelper } from '@/utils/enum-helper';
import {request} from "express";

@injectable()
export class AuthGrpcHandler {
    constructor(
        private validateTokenUseCase: ValidateTokenUseCase,
        @inject('UserRepository') private userRepo: UserRepository,
        @inject('RBACRepository') private rbacRepo: RBACRepository
    ) {
        console.log('AuthGrpcHandler constructed with:', {
            validateTokenUseCase: !!validateTokenUseCase,
            userRepo: !!userRepo,
            rbacRepo: !!rbacRepo
        });
    }

    async findUserByID(
        call: ServerUnaryCall<{ id: number }, any>,
        callback: sendUnaryData<any>
    ): Promise<void> {
        try {
            const user = await this.userRepo.findById(call.request.id);
            if (!user) {
                callback({
                    code: 5, // NOT_FOUND
                    message: 'User not found'
                });
                return;
            }

            callback(null, {
                id: user.id,
                email: user.email,
                role: user.role,
                created_at: user.createdAt.toISOString(),
                updated_at: user.updatedAt.toISOString()
            });
        } catch (error) {
            Logger.error('Error in findUserByID:', error);
            callback({
                code: 13,
                message: 'Internal server error'
            });
        }
    }

    async authenticateAccessToken(
        call: ServerUnaryCall<{ access_token: string }, any>,
        callback: sendUnaryData<any>
    ): Promise<void> {
        try {
            console.log({call});
            // Menggunakan access_token sesuai dengan definisi proto
            const result = await this.validateTokenUseCase.execute(call.request.access_token);

            // Ambil data user
            const user = await this.userRepo.findById(result.userId);
            if (!user) {
                callback({
                    code: 5, // NOT_FOUND
                    message: 'User not found'
                });
                return;
            }

            // Format response sesuai dengan message User di proto
            callback(null, {
                id: user.id,
                email: user.email,
                role: user.role,
                created_at: user.createdAt.toISOString(),
                updated_at: user.updatedAt.toISOString()
            });
        } catch (error) {
            Logger.error('Error in authenticateAccessToken:', error);
            callback({
                code: 16, // UNAUTHENTICATED
                message: 'Invalid token'
            });
        }
    }

    async findRolePermission(
        call: ServerUnaryCall<{ role: string }, any>,
        callback: sendUnaryData<any>
    ): Promise<void> {
        try {
            const role = EnumHelper.toRole(call.request.role);
            const permissions = await this.rbacRepo.loadPermission();
            const rolePermissions = permissions.RRA.get(role);

            if (!rolePermissions) {
                callback({
                    code: 5,
                    message: 'Permissions not found for role'
                });
                return;
            }

            callback(null, {
                role: role,
                permissions: rolePermissions
            });
        } catch (error) {
            Logger.error('Error in findRolePermission:', error);
            callback({
                code: 13,
                message: 'Internal server error'
            });
        }
    }
}
=====================


=====================
server.ts
src/delivery/grpc/server.ts
=====================
// src/delivery/grpc/server.ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import { container } from 'tsyringe';
import { join } from 'path';
import { Logger } from '@/utils/logger';
import { AuthGrpcHandler } from './handlers/auth.handler';
import { Config } from '@/config';
import {ValidateTokenUseCase} from "@/usecase/auth/validate-token.usecase";

export class GrpcServer {
    private server: grpc.Server;
    private authHandler: AuthGrpcHandler;

    constructor() {
        this.server = new grpc.Server();
        this.authHandler = container.resolve(AuthGrpcHandler);

        console.log('Container registrations:', {
            sessionRepo: container.isRegistered('SessionRepository'),
            validateTokenUseCase: container.isRegistered(ValidateTokenUseCase)
        });
    }

    async initialize() {
        // Resolve handler after container setup
        this.authHandler = container.resolve(AuthGrpcHandler);

        console.log('GrpcServer initialized with:', {
            authHandler: !!this.authHandler,
            validateTokenUseCase: container.isRegistered(ValidateTokenUseCase),
            sessionRepo: container.isRegistered('SessionRepository')
        });
    }

    async start(): Promise<void> {
        await this.initialize();

        const packageDefinition = protoLoader.loadSync(
            join(__dirname, '../../../proto/auth.proto'),
            {
                keepCase: true,
                longs: String,
                enums: String,
                defaults: true,
                oneofs: true
            }
        );

        const proto = grpc.loadPackageDefinition(packageDefinition);
        // Debug logging untuk melihat service definition
        console.log('Loaded proto service methods:',
            Object.keys((proto as any).auth.AuthService.service));

        const serviceImplementation = {
            findUserById: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => {
                console.log('findUserById called with request:', call.request);
                return this.authHandler.findUserByID(call, callback);
            },
            authenticateAccessToken: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) =>
                this.authHandler.authenticateAccessToken(call, callback),

            findRolePermission: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) =>
                this.authHandler.findRolePermission(call, callback)
        };

        this.server.addService(
            (proto as any).auth.AuthService.service,
            serviceImplementation
        );

        return new Promise((resolve, reject) => {
            const address = `0.0.0.0:${Config.GRPC_PORT}`;
            this.server.bindAsync(
                address,
                grpc.ServerCredentials.createInsecure(),
                (error, port) => {
                    if (error) {
                        Logger.error('Failed to start gRPC server:', error);
                        reject(error);
                        return;
                    }
                    this.server.start();
                    Logger.info(`gRPC Server listening on ${address}`);
                    resolve();
                }
            );
        });
    }

    async stop(): Promise<void> {
        return new Promise((resolve) => {
            this.server.tryShutdown(() => {
                Logger.info('gRPC Server shutdown complete');
                resolve();
            });
        });
    }
}
=====================


=====================
auth.handler.ts
src/delivery/http/handlers/auth.handler.ts
=====================
// src/delivery/http/handlers/auth.handler.ts
import { Request, Response } from 'express';
import { injectable } from 'tsyringe';
import { LoginUseCase } from '@/usecase/auth/login.usecase';
import { LogoutUseCase } from '@/usecase/auth/logout.usecase';
import { RefreshTokenUseCase } from '@/usecase/auth/refresh-token.usecase';
import { AuthError } from '@/utils/errors';
import { Logger } from '@/utils/logger';

@injectable()
export class AuthHandler {
    constructor(
        private loginUseCase: LoginUseCase,
        private logoutUseCase: LogoutUseCase,
        private refreshTokenUseCase: RefreshTokenUseCase
    ) {}

    async login(req: Request, res: Response): Promise<void> {
        try {
            const { email, password } = req.body;
            const userAgent = req.headers['user-agent'] || '';
            const ipAddress = req.ip || '';

            // Get location from headers or set default
            const latitude = req.headers['x-latitude'] as string || '0';
            const longitude = req.headers['x-longitude'] as string || '0';

            const session = await this.loginUseCase.execute({
                email,
                password,
                userAgent,
                ipAddress,
                latitude,
                longitude
            });

            res.status(200).json({
                status: 'success',
                data: {
                    accessToken: session.accessToken,
                    refreshToken: session.refreshToken,
                    expiresIn: session.expiresIn,
                    tokenType: 'Bearer'
                }
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during login:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }

    async logout(req: Request, res: Response): Promise<void> {
        try {
            const token = req.headers.authorization?.split(' ')[1];
            if (!token) {
                res.status(400).json({
                    status: 'error',
                    message: 'Token is required'
                });
                return;
            }

            await this.logoutUseCase.execute(token);

            res.status(200).json({
                status: 'success',
                message: 'Logged out successfully'
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during logout:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }

    async refreshToken(req: Request, res: Response): Promise<void> {
        try {
            const { refreshToken } = req.body;
            if (!refreshToken) {
                res.status(400).json({
                    status: 'error',
                    message: 'Refresh token is required'
                });
                return;
            }

            const session = await this.refreshTokenUseCase.execute(refreshToken);

            res.status(200).json({
                status: 'success',
                data: {
                    accessToken: session.accessToken,
                    refreshToken: session.refreshToken,
                    expiresIn: session.expiresIn,
                    tokenType: 'Bearer'
                }
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during refresh token:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
}
=====================


=====================
error.handler.ts
src/delivery/http/middlewares/error.handler.ts
=====================
// src/delivery/http/middlewares/error.handler.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';

export const errorHandler = (
    err: Error,
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.error('Error handling request:', {
        message: err.message,
        stack: err.stack,
        path: req.path,
        method: req.method
    });

    res.status(500).json({
        status: 'error',
        message: 'Internal server error'
    });
};
=====================


=====================
request.logger.ts
src/delivery/http/middlewares/request.logger.ts
=====================
// src/delivery/http/middlewares/request.logger.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';

export const requestLogger = (
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.info(`${req.method} ${req.path}`, {
        body: req.body,
        query: req.query,
        ip: req.ip,
        userAgent: req.headers['user-agent']
    });
    next();
};
=====================


=====================
auth.validator.ts
src/delivery/http/middlewares/validators/auth.validator.ts
=====================
// src/delivery/http/middlewares/validators/auth.validator.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

const loginSchema = Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required()
});

const refreshTokenSchema = Joi.object({
    refreshToken: Joi.string().required()
});

export const validateLoginRequest = async (
    req: Request,
    res: Response,
    next: NextFunction
): Promise<void> => {
    try {
        await loginSchema.validateAsync(req.body);
        next();
    } catch (error) {
        if (error instanceof Joi.ValidationError) {
            res.status(400).json({
                status: 'error',
                message: 'Invalid request data',
                errors: error.details // TypeScript sekarang tahu bahwa `error.details` ada
            });
        } else {
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
};

export const validateRefreshTokenRequest = async (
    req: Request,
    res: Response,
    next: NextFunction
): Promise<void> => {
    try {
        await refreshTokenSchema.validateAsync(req.body);
        next();
    } catch (error) {
        if (error instanceof Joi.ValidationError) {
            res.status(400).json({
                status: 'error',
                message: 'Invalid request data',
                errors: error.details // Sama seperti di atas
            });
        } else {
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
};
=====================


=====================
auth.route.ts
src/delivery/http/routes/auth.route.ts
=====================
// src/delivery/http/routes/auth.route.ts
import { Router } from 'express';
import { container } from 'tsyringe';
import { AuthHandler } from '../handlers/auth.handler';
import { validateLoginRequest, validateRefreshTokenRequest } from '../middlewares/validators/auth.validator';

export const authRouter = Router();

// Delay resolving AuthHandler until the container is ready
const getAuthHandler = () => container.resolve(AuthHandler);

authRouter.post('/login', validateLoginRequest, (req, res) => getAuthHandler().login(req, res));
authRouter.post('/logout', (req, res) => getAuthHandler().logout(req, res));
authRouter.post('/refresh-token', validateRefreshTokenRequest, (req, res) => getAuthHandler().refreshToken(req, res));
=====================


=====================
index.ts
src/delivery/http/routes/index.ts
=====================
// src/delivery/http/routes/index.ts
import { Router } from 'express';
import { authRouter } from './auth.route';
import { errorHandler } from '../middlewares/error.handler';
import { requestLogger } from '../middlewares/request.logger';

export const setupRoutes = (app: Router): void => {
    // Middlewares
    app.use(requestLogger);

    // Routes
    app.use('/api/v1/auth', authRouter);

    // Error Handler
    app.use(errorHandler);
};
=====================


=====================
action.entity.ts
src/domain/entities/action.entity.ts
=====================
// src/domain/entities/action.entity.ts
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('actions')
export class Action {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
resource.entity.ts
src/domain/entities/resource.entity.ts
=====================
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('resources')
export class Resource {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
roleResourceAction.entity.ts
src/domain/entities/roleResourceAction.entity.ts
=====================
import { Entity, Column, PrimaryColumn, ManyToOne, JoinColumn } from 'typeorm';
import { Role } from '@/utils/constants';
import { Resource } from './resource.entity';
import { Action } from './action.entity';

@Entity('role_resource_actions')
export class RoleResourceAction {
    @PrimaryColumn({
        type: 'enum',
        enum: Role
    })
    role!: Role;

    @PrimaryColumn()
    resource!: string;

    @PrimaryColumn()
    action!: string;

    @ManyToOne(() => Resource)
    @JoinColumn({ name: 'resource' })
    resourceRef!: Resource;

    @ManyToOne(() => Action)
    @JoinColumn({ name: 'action' })
    actionRef!: Action;
}
=====================


=====================
session.entity.ts
src/domain/entities/session.entity.ts
=====================
// src/domain/entities/session.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import {Role} from "@/utils/constants";

@Entity('sessions')
export class Session {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ name: 'user_id' })
    userId!: number;

    @Column({ name: 'access_token', unique: true })
    accessToken!: string;

    @Column({ name: 'refresh_token', unique: true })
    refreshToken!: string;

    @Column({ name: 'access_token_expired_at' })
    accessTokenExpiredAt!: Date;

    @Column({ name: 'refresh_token_expired_at' })
    refreshTokenExpiredAt!: Date;

    @Column({ name: 'user_agent' })
    userAgent!: string;

    @Column()
    latitude!: string;

    @Column()
    longitude!: string;

    @Column({ name: 'ip_address' })
    ipAddress!: string;

    @CreateDateColumn({ name: 'created_at' }) // Sesuaikan nama kolom
    createdAt!: Date;

    @UpdateDateColumn({ name: 'updated_at' }) // Sesuaikan nama kolom
    updatedAt!: Date;

    role!: Role;

    isAccessTokenExpired(): boolean {
        return new Date() > this.accessTokenExpiredAt;
    }

    static newSessionTokenCacheKey(token: string): string {
        return `cache:id:session_token:${token}`;
    }

    static newSessionTokenCacheKeyByID(id: number): string {
        return `cache:object:session:id:${id}`;
    }
}
=====================


=====================
user.entity.ts
src/domain/entities/user.entity.ts
=====================
// src/domain/entities/user.entity.ts
import {
    Entity,
    PrimaryGeneratedColumn,
    Column,
    CreateDateColumn,
    UpdateDateColumn,
    BeforeInsert,
    BeforeUpdate
} from 'typeorm';
import { Role } from '@/utils/constants';
import bcrypt from "bcrypt";

@Entity('users')
export class User {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ unique: true })
    email!: string;

    @Column()
    password!: string;

    @Column({
        type: 'enum',
        enum: Role,
        default: Role.EMPLOYEE
    })
    role!: Role;

    @Column({ default: true })

    @CreateDateColumn({ name: 'created_at' }) // Sesuaikan nama kolom
    createdAt!: Date;

    @UpdateDateColumn({ name: 'updated_at' }) // Sesuaikan nama kolom
    updatedAt!: Date;

    @BeforeInsert()
    @BeforeUpdate()
    async hashPassword() {
        if (this.password) {
            this.password = await bcrypt.hash(this.password, 10);
        }
    }
}
=====================


=====================
rbac.repository.ts
src/domain/repositories/rbac.repository.ts
=====================
import { Role } from '@/utils/constants';

export interface Permission {
    RRA: Map<Role, Array<{ resource: string; action: string }>>;
}

export interface RBACRepository {
    createResource(resource: string): Promise<void>;
    createAction(action: string): Promise<void>;
    createRoleResourceAction(role: Role, resource: string, action: string): Promise<void>;
    loadPermission(): Promise<Permission>;
    hasPermission(role: Role, resource: string, action: string): Promise<boolean>;
    initializeDefaultPermissions(): Promise<void>;
    findPermissionsByRole(role: Role): Promise<Array<{ resource: string; action: string }>>;
}
=====================


=====================
session.repository.ts
src/domain/repositories/session.repository.ts
=====================
import { Session } from '../entities/session.entity';
import { TokenType } from '@/utils/constants';

export interface SessionRepository {
    create(session: Session): Promise<Session>;
    findByToken(tokenType: TokenType, token: string): Promise<Session | null>;
    findById(id: number): Promise<Session | null>;
    findByUserId(userId: number): Promise<Session[]>;
    delete(id: number): Promise<void>;
    deleteByUserId(userId: number): Promise<void>;
    refreshToken(oldSession: Session, newSession: Session): Promise<void>;
}
=====================


=====================
user.repository.ts
src/domain/repositories/user.repository.ts
=====================
import { User } from '../entities/user.entity';

export interface UserRepository {
    create(user: User): Promise<User>;
    findById(id: number): Promise<User | null>;
    findByEmail(email: string): Promise<User | null>;
    update(id: number, user: Partial<User>): Promise<User>;
    delete(id: number): Promise<void>;
}
=====================


=====================
auth.usecase.ts
src/domain/usecases/auth.usecase.ts
=====================
import { Role } from '@/utils/constants';

export interface LoginRequest {
    email: string;
    password: string;
    userAgent?: string;
    ipAddress?: string;
    latitude?: string;
    longitude?: string;
}

export interface LoginResponse {
    accessToken: string;
    refreshToken: string;
    user: {
        id: number;
        email: string;
        role: Role;
    };
    expiresIn: number;
}

export interface ValidateTokenResponse {
    userId: number;
    role: Role;
    permissions: Map<string, string[]>;
}

export interface AuthUseCase {
    login(req: LoginRequest): Promise<LoginResponse>;
    validateToken(token: string): Promise<ValidateTokenResponse>;
    refreshToken(token: string): Promise<LoginResponse>;
    logout(token: string): Promise<void>;
}
=====================


=====================
index.ts
src/index.ts
=====================
// src/index.ts
import 'reflect-metadata';
import { Command } from 'commander';
import { Server } from './console/server';
import { migrateCommand } from './console/migrate';
import { createMigrationCommand } from './console/create-migration';
import { userSeederCommand } from './console/user.seeder';
import { migrateRBACCommand } from './console/migrate-rbac';

const program = new Command();

program
    .name('auth-service')
    .description('Authentication Service CLI')
    .version('1.0.0');

// Add commands
program.addCommand(migrateCommand);
program.addCommand(createMigrationCommand);
program.addCommand(migrateRBACCommand);
program.addCommand(userSeederCommand);

// Add server command
program
    .command('serve')
    .description('Start the server')
    .action(async () => {
        const server = new Server();
        await server.start();
    });

program.parse();
=====================


=====================
auth_grpc_pb.d.ts
src/proto/auth_grpc_pb.d.ts
=====================
// package: auth
// file: auth.proto

/* tslint:disable */
/* eslint-disable */

import * as grpc from "@grpc/grpc-js";
import * as auth_pb from "./auth_pb";

interface IAuthServiceService extends grpc.ServiceDefinition<grpc.UntypedServiceImplementation> {
    findUserById: IAuthServiceService_IFindUserById;
    authenticateAccessToken: IAuthServiceService_IAuthenticateAccessToken;
    findRolePermission: IAuthServiceService_IFindRolePermission;
}

interface IAuthServiceService_IFindUserById extends grpc.MethodDefinition<auth_pb.FindByIdRequest, auth_pb.User> {
    path: "/auth.AuthService/FindUserById";
    requestStream: false;
    responseStream: false;
    requestSerialize: grpc.serialize<auth_pb.FindByIdRequest>;
    requestDeserialize: grpc.deserialize<auth_pb.FindByIdRequest>;
    responseSerialize: grpc.serialize<auth_pb.User>;
    responseDeserialize: grpc.deserialize<auth_pb.User>;
}
interface IAuthServiceService_IAuthenticateAccessToken extends grpc.MethodDefinition<auth_pb.AuthenticateAccessTokenRequest, auth_pb.User> {
    path: "/auth.AuthService/AuthenticateAccessToken";
    requestStream: false;
    responseStream: false;
    requestSerialize: grpc.serialize<auth_pb.AuthenticateAccessTokenRequest>;
    requestDeserialize: grpc.deserialize<auth_pb.AuthenticateAccessTokenRequest>;
    responseSerialize: grpc.serialize<auth_pb.User>;
    responseDeserialize: grpc.deserialize<auth_pb.User>;
}
interface IAuthServiceService_IFindRolePermission extends grpc.MethodDefinition<auth_pb.FindRolePermissionRequest, auth_pb.RolePermission> {
    path: "/auth.AuthService/FindRolePermission";
    requestStream: false;
    responseStream: false;
    requestSerialize: grpc.serialize<auth_pb.FindRolePermissionRequest>;
    requestDeserialize: grpc.deserialize<auth_pb.FindRolePermissionRequest>;
    responseSerialize: grpc.serialize<auth_pb.RolePermission>;
    responseDeserialize: grpc.deserialize<auth_pb.RolePermission>;
}

export const AuthServiceService: IAuthServiceService;

export interface IAuthServiceServer extends grpc.UntypedServiceImplementation {
    findUserById: grpc.handleUnaryCall<auth_pb.FindByIdRequest, auth_pb.User>;
    authenticateAccessToken: grpc.handleUnaryCall<auth_pb.AuthenticateAccessTokenRequest, auth_pb.User>;
    findRolePermission: grpc.handleUnaryCall<auth_pb.FindRolePermissionRequest, auth_pb.RolePermission>;
}

export interface IAuthServiceClient {
    findUserById(request: auth_pb.FindByIdRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    findUserById(request: auth_pb.FindByIdRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    findUserById(request: auth_pb.FindByIdRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    findRolePermission(request: auth_pb.FindRolePermissionRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
    findRolePermission(request: auth_pb.FindRolePermissionRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
    findRolePermission(request: auth_pb.FindRolePermissionRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
}

export class AuthServiceClient extends grpc.Client implements IAuthServiceClient {
    constructor(address: string, credentials: grpc.ChannelCredentials, options?: Partial<grpc.ClientOptions>);
    public findUserById(request: auth_pb.FindByIdRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public findUserById(request: auth_pb.FindByIdRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public findUserById(request: auth_pb.FindByIdRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public authenticateAccessToken(request: auth_pb.AuthenticateAccessTokenRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.User) => void): grpc.ClientUnaryCall;
    public findRolePermission(request: auth_pb.FindRolePermissionRequest, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
    public findRolePermission(request: auth_pb.FindRolePermissionRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
    public findRolePermission(request: auth_pb.FindRolePermissionRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: auth_pb.RolePermission) => void): grpc.ClientUnaryCall;
}

=====================


=====================
auth_grpc_pb.js
src/proto/auth_grpc_pb.js
=====================
// GENERATED CODE -- DO NOT EDIT!

// Original file comments:
// proto/auth.proto
'use strict';
var grpc = require('@grpc/grpc-js');
var auth_pb = require('./auth_pb.js');

function serialize_auth_AuthenticateAccessTokenRequest(arg) {
  if (!(arg instanceof auth_pb.AuthenticateAccessTokenRequest)) {
    throw new Error('Expected argument of type auth.AuthenticateAccessTokenRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_auth_AuthenticateAccessTokenRequest(buffer_arg) {
  return auth_pb.AuthenticateAccessTokenRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_auth_FindByIdRequest(arg) {
  if (!(arg instanceof auth_pb.FindByIdRequest)) {
    throw new Error('Expected argument of type auth.FindByIdRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_auth_FindByIdRequest(buffer_arg) {
  return auth_pb.FindByIdRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_auth_FindRolePermissionRequest(arg) {
  if (!(arg instanceof auth_pb.FindRolePermissionRequest)) {
    throw new Error('Expected argument of type auth.FindRolePermissionRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_auth_FindRolePermissionRequest(buffer_arg) {
  return auth_pb.FindRolePermissionRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_auth_RolePermission(arg) {
  if (!(arg instanceof auth_pb.RolePermission)) {
    throw new Error('Expected argument of type auth.RolePermission');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_auth_RolePermission(buffer_arg) {
  return auth_pb.RolePermission.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_auth_User(arg) {
  if (!(arg instanceof auth_pb.User)) {
    throw new Error('Expected argument of type auth.User');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_auth_User(buffer_arg) {
  return auth_pb.User.deserializeBinary(new Uint8Array(buffer_arg));
}


var AuthServiceService = exports.AuthServiceService = {
  findUserById: {
    path: '/auth.AuthService/FindUserById',
    requestStream: false,
    responseStream: false,
    requestType: auth_pb.FindByIdRequest,
    responseType: auth_pb.User,
    requestSerialize: serialize_auth_FindByIdRequest,
    requestDeserialize: deserialize_auth_FindByIdRequest,
    responseSerialize: serialize_auth_User,
    responseDeserialize: deserialize_auth_User,
  },
  authenticateAccessToken: {
    path: '/auth.AuthService/AuthenticateAccessToken',
    requestStream: false,
    responseStream: false,
    requestType: auth_pb.AuthenticateAccessTokenRequest,
    responseType: auth_pb.User,
    requestSerialize: serialize_auth_AuthenticateAccessTokenRequest,
    requestDeserialize: deserialize_auth_AuthenticateAccessTokenRequest,
    responseSerialize: serialize_auth_User,
    responseDeserialize: deserialize_auth_User,
  },
  findRolePermission: {
    path: '/auth.AuthService/FindRolePermission',
    requestStream: false,
    responseStream: false,
    requestType: auth_pb.FindRolePermissionRequest,
    responseType: auth_pb.RolePermission,
    requestSerialize: serialize_auth_FindRolePermissionRequest,
    requestDeserialize: deserialize_auth_FindRolePermissionRequest,
    responseSerialize: serialize_auth_RolePermission,
    responseDeserialize: deserialize_auth_RolePermission,
  },
};

exports.AuthServiceClient = grpc.makeGenericClientConstructor(AuthServiceService);

=====================


=====================
auth_pb.d.ts
src/proto/auth_pb.d.ts
=====================
// package: auth
// file: auth.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";

export class FindByIdRequest extends jspb.Message { 
    getId(): number;
    setId(value: number): FindByIdRequest;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FindByIdRequest.AsObject;
    static toObject(includeInstance: boolean, msg: FindByIdRequest): FindByIdRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FindByIdRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FindByIdRequest;
    static deserializeBinaryFromReader(message: FindByIdRequest, reader: jspb.BinaryReader): FindByIdRequest;
}

export namespace FindByIdRequest {
    export type AsObject = {
        id: number,
    }
}

export class AuthenticateAccessTokenRequest extends jspb.Message { 
    getAccessToken(): string;
    setAccessToken(value: string): AuthenticateAccessTokenRequest;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AuthenticateAccessTokenRequest.AsObject;
    static toObject(includeInstance: boolean, msg: AuthenticateAccessTokenRequest): AuthenticateAccessTokenRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AuthenticateAccessTokenRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AuthenticateAccessTokenRequest;
    static deserializeBinaryFromReader(message: AuthenticateAccessTokenRequest, reader: jspb.BinaryReader): AuthenticateAccessTokenRequest;
}

export namespace AuthenticateAccessTokenRequest {
    export type AsObject = {
        accessToken: string,
    }
}

export class FindRolePermissionRequest extends jspb.Message { 
    getRole(): string;
    setRole(value: string): FindRolePermissionRequest;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): FindRolePermissionRequest.AsObject;
    static toObject(includeInstance: boolean, msg: FindRolePermissionRequest): FindRolePermissionRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: FindRolePermissionRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): FindRolePermissionRequest;
    static deserializeBinaryFromReader(message: FindRolePermissionRequest, reader: jspb.BinaryReader): FindRolePermissionRequest;
}

export namespace FindRolePermissionRequest {
    export type AsObject = {
        role: string,
    }
}

export class User extends jspb.Message { 
    getId(): number;
    setId(value: number): User;
    getEmail(): string;
    setEmail(value: string): User;
    getRole(): string;
    setRole(value: string): User;
    getCreatedAt(): string;
    setCreatedAt(value: string): User;
    getUpdatedAt(): string;
    setUpdatedAt(value: string): User;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): User.AsObject;
    static toObject(includeInstance: boolean, msg: User): User.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: User, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): User;
    static deserializeBinaryFromReader(message: User, reader: jspb.BinaryReader): User;
}

export namespace User {
    export type AsObject = {
        id: number,
        email: string,
        role: string,
        createdAt: string,
        updatedAt: string,
    }
}

export class Permission extends jspb.Message { 
    getResource(): string;
    setResource(value: string): Permission;
    getAction(): string;
    setAction(value: string): Permission;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Permission.AsObject;
    static toObject(includeInstance: boolean, msg: Permission): Permission.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Permission, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Permission;
    static deserializeBinaryFromReader(message: Permission, reader: jspb.BinaryReader): Permission;
}

export namespace Permission {
    export type AsObject = {
        resource: string,
        action: string,
    }
}

export class RolePermission extends jspb.Message { 
    getRole(): string;
    setRole(value: string): RolePermission;
    clearPermissionsList(): void;
    getPermissionsList(): Array<Permission>;
    setPermissionsList(value: Array<Permission>): RolePermission;
    addPermissions(value?: Permission, index?: number): Permission;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RolePermission.AsObject;
    static toObject(includeInstance: boolean, msg: RolePermission): RolePermission.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RolePermission, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RolePermission;
    static deserializeBinaryFromReader(message: RolePermission, reader: jspb.BinaryReader): RolePermission;
}

export namespace RolePermission {
    export type AsObject = {
        role: string,
        permissionsList: Array<Permission.AsObject>,
    }
}

=====================


=====================
auth_pb.js
src/proto/auth_pb.js
=====================
// source: auth.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = (function() {
  if (this) { return this; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  if (typeof self !== 'undefined') { return self; }
  return Function('return this')();
}.call(null));

goog.exportSymbol('proto.auth.AuthenticateAccessTokenRequest', null, global);
goog.exportSymbol('proto.auth.FindByIdRequest', null, global);
goog.exportSymbol('proto.auth.FindRolePermissionRequest', null, global);
goog.exportSymbol('proto.auth.Permission', null, global);
goog.exportSymbol('proto.auth.RolePermission', null, global);
goog.exportSymbol('proto.auth.User', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.FindByIdRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.auth.FindByIdRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.FindByIdRequest.displayName = 'proto.auth.FindByIdRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.AuthenticateAccessTokenRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.auth.AuthenticateAccessTokenRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.AuthenticateAccessTokenRequest.displayName = 'proto.auth.AuthenticateAccessTokenRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.FindRolePermissionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.auth.FindRolePermissionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.FindRolePermissionRequest.displayName = 'proto.auth.FindRolePermissionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.User = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.auth.User, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.User.displayName = 'proto.auth.User';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.Permission = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.auth.Permission, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.Permission.displayName = 'proto.auth.Permission';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.auth.RolePermission = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.auth.RolePermission.repeatedFields_, null);
};
goog.inherits(proto.auth.RolePermission, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.auth.RolePermission.displayName = 'proto.auth.RolePermission';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.FindByIdRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.FindByIdRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.FindByIdRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.FindByIdRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.FindByIdRequest}
 */
proto.auth.FindByIdRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.FindByIdRequest;
  return proto.auth.FindByIdRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.FindByIdRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.FindByIdRequest}
 */
proto.auth.FindByIdRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.FindByIdRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.FindByIdRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.FindByIdRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.FindByIdRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.auth.FindByIdRequest.prototype.getId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.auth.FindByIdRequest} returns this
 */
proto.auth.FindByIdRequest.prototype.setId = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.AuthenticateAccessTokenRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.AuthenticateAccessTokenRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.AuthenticateAccessTokenRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.AuthenticateAccessTokenRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accessToken: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.AuthenticateAccessTokenRequest}
 */
proto.auth.AuthenticateAccessTokenRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.AuthenticateAccessTokenRequest;
  return proto.auth.AuthenticateAccessTokenRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.AuthenticateAccessTokenRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.AuthenticateAccessTokenRequest}
 */
proto.auth.AuthenticateAccessTokenRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccessToken(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.AuthenticateAccessTokenRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.AuthenticateAccessTokenRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.AuthenticateAccessTokenRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.AuthenticateAccessTokenRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccessToken();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string access_token = 1;
 * @return {string}
 */
proto.auth.AuthenticateAccessTokenRequest.prototype.getAccessToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.AuthenticateAccessTokenRequest} returns this
 */
proto.auth.AuthenticateAccessTokenRequest.prototype.setAccessToken = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.FindRolePermissionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.FindRolePermissionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.FindRolePermissionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.FindRolePermissionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    role: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.FindRolePermissionRequest}
 */
proto.auth.FindRolePermissionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.FindRolePermissionRequest;
  return proto.auth.FindRolePermissionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.FindRolePermissionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.FindRolePermissionRequest}
 */
proto.auth.FindRolePermissionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setRole(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.FindRolePermissionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.FindRolePermissionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.FindRolePermissionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.FindRolePermissionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRole();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string role = 1;
 * @return {string}
 */
proto.auth.FindRolePermissionRequest.prototype.getRole = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.FindRolePermissionRequest} returns this
 */
proto.auth.FindRolePermissionRequest.prototype.setRole = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.User.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.User.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.User} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.User.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, 0),
    email: jspb.Message.getFieldWithDefault(msg, 2, ""),
    role: jspb.Message.getFieldWithDefault(msg, 3, ""),
    createdAt: jspb.Message.getFieldWithDefault(msg, 4, ""),
    updatedAt: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.User}
 */
proto.auth.User.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.User;
  return proto.auth.User.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.User} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.User}
 */
proto.auth.User.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setEmail(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setRole(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setCreatedAt(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setUpdatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.User.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.User.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.User} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.User.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getEmail();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRole();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getCreatedAt();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getUpdatedAt();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.auth.User.prototype.getId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.auth.User} returns this
 */
proto.auth.User.prototype.setId = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string email = 2;
 * @return {string}
 */
proto.auth.User.prototype.getEmail = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.User} returns this
 */
proto.auth.User.prototype.setEmail = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string role = 3;
 * @return {string}
 */
proto.auth.User.prototype.getRole = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.User} returns this
 */
proto.auth.User.prototype.setRole = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string created_at = 4;
 * @return {string}
 */
proto.auth.User.prototype.getCreatedAt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.User} returns this
 */
proto.auth.User.prototype.setCreatedAt = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string updated_at = 5;
 * @return {string}
 */
proto.auth.User.prototype.getUpdatedAt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.User} returns this
 */
proto.auth.User.prototype.setUpdatedAt = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.Permission.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.Permission.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.Permission} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.Permission.toObject = function(includeInstance, msg) {
  var f, obj = {
    resource: jspb.Message.getFieldWithDefault(msg, 1, ""),
    action: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.Permission}
 */
proto.auth.Permission.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.Permission;
  return proto.auth.Permission.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.Permission} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.Permission}
 */
proto.auth.Permission.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setResource(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.Permission.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.Permission.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.Permission} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.Permission.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getResource();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAction();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string resource = 1;
 * @return {string}
 */
proto.auth.Permission.prototype.getResource = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.Permission} returns this
 */
proto.auth.Permission.prototype.setResource = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string action = 2;
 * @return {string}
 */
proto.auth.Permission.prototype.getAction = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.Permission} returns this
 */
proto.auth.Permission.prototype.setAction = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.auth.RolePermission.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.auth.RolePermission.prototype.toObject = function(opt_includeInstance) {
  return proto.auth.RolePermission.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.auth.RolePermission} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.RolePermission.toObject = function(includeInstance, msg) {
  var f, obj = {
    role: jspb.Message.getFieldWithDefault(msg, 1, ""),
    permissionsList: jspb.Message.toObjectList(msg.getPermissionsList(),
    proto.auth.Permission.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.auth.RolePermission}
 */
proto.auth.RolePermission.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.auth.RolePermission;
  return proto.auth.RolePermission.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.auth.RolePermission} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.auth.RolePermission}
 */
proto.auth.RolePermission.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setRole(value);
      break;
    case 2:
      var value = new proto.auth.Permission;
      reader.readMessage(value,proto.auth.Permission.deserializeBinaryFromReader);
      msg.addPermissions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.auth.RolePermission.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.auth.RolePermission.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.auth.RolePermission} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.auth.RolePermission.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRole();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPermissionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.auth.Permission.serializeBinaryToWriter
    );
  }
};


/**
 * optional string role = 1;
 * @return {string}
 */
proto.auth.RolePermission.prototype.getRole = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.auth.RolePermission} returns this
 */
proto.auth.RolePermission.prototype.setRole = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated Permission permissions = 2;
 * @return {!Array<!proto.auth.Permission>}
 */
proto.auth.RolePermission.prototype.getPermissionsList = function() {
  return /** @type{!Array<!proto.auth.Permission>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.auth.Permission, 2));
};


/**
 * @param {!Array<!proto.auth.Permission>} value
 * @return {!proto.auth.RolePermission} returns this
*/
proto.auth.RolePermission.prototype.setPermissionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.auth.Permission=} opt_value
 * @param {number=} opt_index
 * @return {!proto.auth.Permission}
 */
proto.auth.RolePermission.prototype.addPermissions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.auth.Permission, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.auth.RolePermission} returns this
 */
proto.auth.RolePermission.prototype.clearPermissionsList = function() {
  return this.setPermissionsList([]);
};


goog.object.extend(exports, proto.auth);

=====================


=====================
rbac.repository.ts
src/repository/rbac.repository.ts
=====================
// src/repository/rbac.repository.ts
import { injectable, inject } from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { DEFAULT_ACTIONS, DEFAULT_RESOURCES, Role } from '@/utils/constants';
import { Resource } from '@/domain/entities/resource.entity';
import { Action } from '@/domain/entities/action.entity';
import { RoleResourceAction } from '@/domain/entities/roleResourceAction.entity';
import { RBACRepository, Permission } from '@/domain/repositories/rbac.repository';

@injectable()
export class RBACRepositoryImpl implements RBACRepository {
    private resourceRepo: Repository<Resource>;
    private actionRepo: Repository<Action>;
    private rraRepo: Repository<RoleResourceAction>;
    private RBAC_PERMISSION_CACHE_KEY = 'cache:object:rbac:permission';

    constructor(
        @inject('DataSource') private dataSource: DataSource, // Inject DataSource
        @inject('Redis') private redis: Redis // Inject Redis
    ) {
        if (!dataSource.isInitialized) {
            throw new Error('DataSource is not initialized');
        }

        this.resourceRepo = dataSource.getRepository(Resource);
        this.actionRepo = dataSource.getRepository(Action);
        this.rraRepo = dataSource.getRepository(RoleResourceAction);
    }

    async createResource(resource: string): Promise<void> {
        const res = new Resource();
        res.id = resource;
        await this.resourceRepo.save(res);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createAction(action: string): Promise<void> {
        const act = new Action();
        act.id = action;
        await this.actionRepo.save(act);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createRoleResourceAction(role: Role, resource: string, action: string): Promise<void> {
        const rra = new RoleResourceAction();
        rra.role = role;
        rra.resource = resource;
        rra.action = action;
        await this.rraRepo.save(rra);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async loadPermission(): Promise<Permission> {
        const cachedPermission = await this.redis.get(this.RBAC_PERMISSION_CACHE_KEY);
        if (cachedPermission) {
            const parsed = JSON.parse(cachedPermission);
            // Konversi object ke Map dengan tipe yang benar
            const rraMap = new Map<Role, Array<{ resource: string; action: string }>>();

            // Iterasi setiap entry dan konversi ke format yang benar
            Object.entries(parsed.RRA).forEach(([role, permissions]) => {
                rraMap.set(role as Role, permissions as Array<{ resource: string; action: string }>);
            });

            return { RRA: rraMap };
        }

        const permissions = await this.rraRepo.find();
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();

        permissions.forEach(permission => {
            const rolePermissions = permissionMap.get(permission.role) || [];
            rolePermissions.push({
                resource: permission.resource,
                action: permission.action
            });
            permissionMap.set(permission.role, rolePermissions);
        });

        // Konversi Map ke Object sebelum cache
        const permissionObject = {
            RRA: Object.fromEntries(permissionMap)
        };

        await this.redis.set(
            this.RBAC_PERMISSION_CACHE_KEY,
            JSON.stringify(permissionObject),
            'EX',
            3600
        );

        return { RRA: permissionMap };
    }

    async hasPermission(role: Role, resource: string, action: string): Promise<boolean> {
        const permission = await this.loadPermission();
        const rolePermissions = permission.RRA.get(role) || [];

        return rolePermissions.some(
            rra => rra.resource === resource && rra.action === action
        );
    }

    async initializeDefaultPermissions(): Promise<void> {
        // Create default resources
        for (const resource of Object.values(DEFAULT_RESOURCES)) {
            await this.createResource(resource);
        }

        // Create default actions
        for (const action of Object.values(DEFAULT_ACTIONS)) {
            await this.createAction(action);
        }

        // Create default role-resource-actions
        const defaultPermissions = [
            // Admin permissions
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.CREATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.READ },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.UPDATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.DELETE },

            // Manager permissions
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.EMPLOYEE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.APPROVE },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.REJECT },

            // Employee permissions
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.SUBMIT },
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
        ];

        for (const perm of defaultPermissions) {
            await this.createRoleResourceAction(perm.role, perm.resource, perm.action);
        }
    }

    async findPermissionsByRole(role: Role): Promise<Array<{ resource: string; action: string }>> {
        // Cek cache terlebih dahulu
        const cachedPermission = await this.redis.get(this.RBAC_PERMISSION_CACHE_KEY);
        if (cachedPermission) {
            const parsed = JSON.parse(cachedPermission);
            const rraMap = new Map<Role, Array<{ resource: string; action: string }>>();

            // Konversi cached data
            Object.entries(parsed.RRA).forEach(([cachedRole, permissions]) => {
                rraMap.set(cachedRole as Role, permissions as Array<{ resource: string; action: string }>);
            });

            // Ambil permissions untuk role yang diminta
            const rolePermissions = rraMap.get(role);
            if (rolePermissions) {
                return rolePermissions;
            }
        }

        // Jika tidak ada di cache, ambil dari database
        const permissions = await this.rraRepo.find({
            where: { role }
        });

        const result = permissions.map(p => ({
            resource: p.resource,
            action: p.action
        }));

        // Update cache dengan data baru
        const allPermissions = await this.rraRepo.find();
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();

        allPermissions.forEach(permission => {
            const rolePermissions = permissionMap.get(permission.role) || [];
            rolePermissions.push({
                resource: permission.resource,
                action: permission.action
            });
            permissionMap.set(permission.role, rolePermissions);
        });

        // Simpan ke cache
        const permissionObject = {
            RRA: Object.fromEntries(permissionMap)
        };

        await this.redis.set(
            this.RBAC_PERMISSION_CACHE_KEY,
            JSON.stringify(permissionObject),
            'EX',
            3600
        );

        return result;
    }
}
=====================


=====================
session.repository.ts
src/repository/session.repository.ts
=====================
// src/repository/session.repository.ts
import {inject, injectable} from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { Session } from '@/domain/entities/session.entity';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { TokenType } from '@/utils/constants';

@injectable()
export class SessionRepositoryImpl implements SessionRepository {
    private repository: Repository<Session>;

    constructor(
        @inject('DataSource') private dataSource: DataSource,
        @inject('Redis') private redis: Redis
    ) {
        if (!dataSource.isInitialized) {
            throw new Error('DataSource is not initialized');
        }
        this.repository = dataSource.getRepository(Session);
    }

    async create(session: Session): Promise<Session> {
        const savedSession = await this.repository.save(session);
        await this.cacheSession(savedSession);
        return savedSession;
    }

    async findByToken(tokenType: TokenType, token: string): Promise<Session | null> {
        console.log(`SessionRepositoryImpl.findByToken called with type: ${tokenType}, token: ${token}`);

        const cacheKey = Session.newSessionTokenCacheKey(token);

        // Try to get from cache first
        const cachedSession = await this.redis.get(cacheKey);
        if (cachedSession) {
            const sessionData = JSON.parse(cachedSession);
            return this.transformToSessionEntity(sessionData);
        }

        const session = await this.repository.findOne({
            where: tokenType === TokenType.ACCESS_TOKEN
                ? { accessToken: token }
                : { refreshToken: token }
        });

        if (session) {
            // Cache the session
            await this.cacheSession(session);
            return this.transformToSessionEntity(session);
        }

        return session;
    }

    private transformToSessionEntity(data: any): Session {
        const session = new Session();
        Object.assign(session, {
            id: data.id,
            userId: data.userId,
            accessToken: data.accessToken,
            refreshToken: data.refreshToken,
            accessTokenExpiredAt: new Date(data.accessTokenExpiredAt),
            refreshTokenExpiredAt: new Date(data.refreshTokenExpiredAt),
            userAgent: data.userAgent,
            latitude: data.latitude,
            longitude: data.longitude,
            ipAddress: data.ipAddress,
            createdAt: new Date(data.createdAt),
            updatedAt: new Date(data.updatedAt),
            role: data.role
        });
        return session;
    }

    private async cacheSession(session: Session): Promise<void> {
        const cacheKey = Session.newSessionTokenCacheKey(session.accessToken);
        await this.redis.set(cacheKey, JSON.stringify(session), 'EX', 3600); // 1 hour
    }

    async delete(id: number): Promise<void> {
        await this.repository.delete(id);
        const cacheKey = Session.newSessionTokenCacheKeyByID(id);
        await this.redis.del(cacheKey);
    }

    async deleteByUserId(userId: number): Promise<void> {
        const sessions = await this.repository.find({ where: { userId } });
        for (const session of sessions) {
            await this.delete(session.id);
        }
    }

    async findById(id: number): Promise<Session | null> {
        const cacheKey = Session.newSessionTokenCacheKeyByID(id);
        const cachedSession = await this.redis.get(cacheKey);

        if (cachedSession) {
            return JSON.parse(cachedSession);
        }

        const session = await this.repository.findOne({
            where: { id: id }
        });

        if (session) {
            await this.cacheSession(session);
        }

        return session;
    }

    async findByUserId(userId: number): Promise<Session[]> {
        return await this.repository.find({ where: { userId } });
    }

    // Implementasi refreshToken
    async refreshToken(oldSession: Session, newSession: Session): Promise<void> {
        // Hapus sesi lama
        await this.delete(oldSession.id);

        // Simpan sesi baru
        await this.create(newSession);
    }
}
=====================


=====================
user.repository.ts
src/repository/user.repository.ts
=====================
import {inject, injectable} from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { User } from '@/domain/entities/user.entity';
import { UserRepository } from '@/domain/repositories/user.repository';

@injectable()
export class UserRepositoryImpl implements UserRepository {
    private repository: Repository<User>;

    constructor(@inject('DataSource') dataSource: DataSource) {
        this.repository = dataSource.getRepository(User);
    }

    async create(user: User): Promise<User> {
        return await this.repository.save(user);
    }

    async findById(id: number): Promise<User | null> {
        return await this.repository.findOneBy({ id });
    }

    async findByEmail(email: string): Promise<User | null> {
        return await this.repository.findOneBy({ email });
    }

    async update(id: number, userData: Partial<User>): Promise<User> {
        await this.repository.update(id, userData);
        return (await this.findById(id))!;
    }

    async delete(id: number): Promise<void> {
        await this.repository.delete(id);
    }
}
=====================


=====================
login.usecase.ts
src/usecase/auth/login.usecase.ts
=====================
// src/usecase/auth/login.usecase.ts
import { inject, injectable } from 'tsyringe';
import bcrypt from 'bcrypt';
import { randomBytes } from 'crypto';
import { UserRepository } from '@/domain/repositories/user.repository';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { LoginRequest, LoginResponse } from '@/domain/usecases/auth.usecase';
import { Session } from '@/domain/entities/session.entity';
import { AuthError } from '@/utils/errors';

@injectable()
export class LoginUseCase {
    constructor(
        @inject('UserRepository') private userRepo: UserRepository,
        @inject('SessionRepository') private sessionRepo: SessionRepository,
        @inject('RBACRepository') private rbacRepo: RBACRepository
    ) {}

    async execute(req: LoginRequest): Promise<LoginResponse> {
        // Find user
        const user = await this.userRepo.findByEmail(req.email);
        if (!user) {
            throw new AuthError('Invalid email or password');
        }

        // Validate password
        const isValidPassword = await bcrypt.compare(req.password, user.password).catch(() => false);
        if (!isValidPassword) {
            throw new AuthError('Invalid email or password');
        }

        // Validate latitude and longitude
        const latitude = req.latitude || '0';
        const longitude = req.longitude || '0';
        if (isNaN(parseFloat(latitude)) || isNaN(parseFloat(longitude))) {
            throw new AuthError('Invalid location data');
        }

        // Generate tokens
        const accessToken = randomBytes(32).toString('hex');
        const refreshToken = randomBytes(32).toString('hex');

        // Create session
        const now = new Date();
        const session = new Session();
        session.userId = user.id;
        session.accessToken = accessToken;
        session.refreshToken = refreshToken;
        session.accessTokenExpiredAt = new Date(now.getTime() + 1 * 60 * 60 * 1000); // 1 hour
        session.refreshTokenExpiredAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
        session.userAgent = req.userAgent || '';
        session.ipAddress = req.ipAddress || '';
        session.latitude = latitude;
        session.longitude = longitude;
        session.createdAt = now;
        session.updatedAt = now;

        await this.sessionRepo.create(session);

        // Load permissions
        const permissions = await this.rbacRepo.loadPermission();

        return {
            accessToken,
            refreshToken,
            user: {
                id: user.id,
                email: user.email,
                role: user.role,
            },
            expiresIn: session.accessTokenExpiredAt.getTime(),
        };
    }
}
=====================


=====================
logout.usecase.ts
src/usecase/auth/logout.usecase.ts
=====================
import {inject, injectable} from 'tsyringe';
import {SessionRepository} from '@/domain/repositories/session.repository';
import {AuthError} from '@/utils/errors';
import {TokenType} from "@/utils/constants";

@injectable()
export class LogoutUseCase {
    constructor(
        @inject('SessionRepository') private sessionRepo: SessionRepository
    ) {}

    async execute(token: string): Promise<void> {
        const session = await this.sessionRepo.findByToken(TokenType.ACCESS_TOKEN, token);
        if (!session) {
            throw new AuthError('Invalid token');
        }

        await this.sessionRepo.delete(session.id);
    }
}
=====================


=====================
refresh-token.usecase.ts
src/usecase/auth/refresh-token.usecase.ts
=====================
// src/usecase/auth/refresh-token.usecase.ts
import { inject, injectable } from 'tsyringe';
import { randomBytes } from 'crypto';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { UserRepository } from '@/domain/repositories/user.repository';
import { LoginResponse } from '@/domain/usecases/auth.usecase';
import { Session } from '@/domain/entities/session.entity';
import { AuthError } from '@/utils/errors';
import { TokenType } from '@/utils/constants';

@injectable()
export class RefreshTokenUseCase {
    constructor(
        @inject('SessionRepository') private sessionRepo: SessionRepository,
        @inject('UserRepository') private userRepo: UserRepository
    ) {}

    async execute(refreshToken: string): Promise<LoginResponse> {
        // Find session by refresh token
        const oldSession = await this.sessionRepo.findByToken(TokenType.REFRESH_TOKEN, refreshToken);
        if (!oldSession) {
            throw new AuthError('Invalid refresh token');
        }

        // Generate new tokens
        const accessToken = randomBytes(32).toString('hex');
        const newRefreshToken = randomBytes(32).toString('hex');

        // Create new session
        const now = new Date();
        const newSession = new Session();
        newSession.userId = oldSession.userId;
        newSession.accessToken = accessToken;
        newSession.refreshToken = newRefreshToken;
        newSession.accessTokenExpiredAt = new Date(now.getTime() + 1 * 60 * 60 * 1000);
        newSession.refreshTokenExpiredAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        newSession.userAgent = oldSession.userAgent;
        newSession.ipAddress = oldSession.ipAddress;
        newSession.latitude = oldSession.latitude;
        newSession.longitude = oldSession.longitude;
        newSession.createdAt = now;
        newSession.updatedAt = now;

        // Refresh session
        await this.sessionRepo.refreshToken(oldSession, newSession);

        // Get user data
        const user = await this.userRepo.findById(oldSession.userId);
        if (!user) {
            throw new AuthError('User not found');
        }

        return {
            accessToken,
            refreshToken: newRefreshToken,
            user: {
                id: user.id,
                email: user.email,
                role: user.role
            },
            expiresIn: newSession.accessTokenExpiredAt.getTime()
        };
    }
}
=====================


=====================
validate-token.usecase.ts
src/usecase/auth/validate-token.usecase.ts
=====================
import {inject, injectable} from 'tsyringe';
import {SessionRepository} from '@/domain/repositories/session.repository';
import {RBACRepository} from '@/domain/repositories/rbac.repository';
import {ValidateTokenResponse} from '@/domain/usecases/auth.usecase';
import {AuthError} from '@/utils/errors';
import {TokenType} from "@/utils/constants";

@injectable()
export class ValidateTokenUseCase {
    constructor(
        @inject('SessionRepository') private sessionRepo: SessionRepository,
        @inject('RBACRepository') private rbacRepo: RBACRepository
    ) {
        console.log('ValidateTokenUseCase constructed with:', {
            sessionRepo: !!sessionRepo,
            rbacRepo: !!rbacRepo
        });
    }

    async execute(token: string): Promise<ValidateTokenResponse> {
        console.log('Executing ValidateTokenUseCase with token:', token);
        const session = await this.sessionRepo.findByToken(TokenType.ACCESS_TOKEN, token);
        if (!session) {
            throw new AuthError('Invalid token');
        }

        // Check if token is expired
        if (session.isAccessTokenExpired()) {
            throw new AuthError('Token expired');
        }

        // Load user permissions
        const permissions = await this.rbacRepo.loadPermission();
        const userPermissions = permissions.RRA.get(session.role) || [];

        // Transform permissions to map for easier access
        const permissionMap = new Map<string, string[]>();
        userPermissions.forEach(({ resource, action }) => {
            const actions = permissionMap.get(resource) || [];
            actions.push(action);
            permissionMap.set(resource, actions);
        });

        return {
            userId: session.userId,
            role: session.role,
            permissions: permissionMap
        };
    }
}
=====================


=====================
SqlMigrationLoader.ts
src/utils/SqlMigrationLoader.ts
=====================
// src/database/SqlMigrationLoader.ts
import { readFileSync, readdirSync } from 'fs';
import { join } from 'path';
import { MigrationInterface, QueryRunner } from 'typeorm';

export function createSqlMigrationClass(filename: string): new () => MigrationInterface {
    // Extract timestamp and name from filename (format: YYYYMMDDHHMMSS-name.sql)
    const [timestamp, ...nameParts] = filename.replace('.sql', '').split('-');
    const migrationName = nameParts.join('-');

    // Convert the timestamp (YYYYMMDDHHMMSS) to JavaScript timestamp (milliseconds)
    const year = parseInt(timestamp.slice(0, 4));
    const month = parseInt(timestamp.slice(4, 6)) - 1; // Month is 0-based in JS
    const day = parseInt(timestamp.slice(6, 8));
    const hour = parseInt(timestamp.slice(8, 10));
    const minute = parseInt(timestamp.slice(10, 12));
    const second = parseInt(timestamp.slice(12, 14));
    const jsTimestamp = new Date(year, month, day, hour, minute, second).getTime();

    const migrationContent = readFileSync(
        join(__dirname, '../../db/migration', filename),
        'utf8'
    );

    const [upQuery, downQuery] = migrationContent.split('-- +migrate Down');
    const up = upQuery.replace('-- +migrate Up', '').trim();
    const down = downQuery ? downQuery.trim() : '';

    const MigrationClass = class implements MigrationInterface {
        public name = `${jsTimestamp}-${migrationName}`;

        public async up(queryRunner: QueryRunner): Promise<void> {
            await queryRunner.query(up);
        }

        public async down(queryRunner: QueryRunner): Promise<void> {
            if (down) {
                await queryRunner.query(down);
            }
        }
    };

    // Set the name property of the class itself
    Object.defineProperty(MigrationClass, 'name', { value: `${jsTimestamp}-${migrationName}` });

    return MigrationClass;
}

export function loadSqlMigrations(): Function[] {
    const migrationsPath = join(__dirname, '../../db/migration');
    const files = readdirSync(migrationsPath)
        .filter(file => file.endsWith('.sql'))
        .sort();

    return files.map(filename => createSqlMigrationClass(filename));
}
=====================


=====================
constants.ts
src/utils/constants.ts
=====================
// src/utils/constants.ts
export enum Role {
    ADMIN = 'ADMIN',
    MANAGER = 'MANAGER',
    EMPLOYEE = 'EMPLOYEE'
}

export const DEFAULT_RESOURCES = {
    USER: 'user',
    EMPLOYEE: 'employee',
    ATTENDANCE: 'attendance',
    SESSION: 'session',
    REPORT: 'report'
} as const;

export const DEFAULT_ACTIONS = {
    CREATE: 'create',
    READ: 'read',
    UPDATE: 'update',
    DELETE: 'delete',
    APPROVE: 'approve',
    REJECT: 'reject',
    SUBMIT: 'submit'
} as const;

export enum TokenType {
    ACCESS_TOKEN = 0,
    REFRESH_TOKEN = 1
}
=====================


=====================
enum-helper.ts
src/utils/enum-helper.ts
=====================
// src/utils/enum-helper.ts
import { Role } from '@/utils/constants';

export class EnumHelper {
    static isValidRole(role: string): role is Role {
        return Object.values(Role).includes(role as Role);
    }

    static toRole(role: string): Role {
        if (!this.isValidRole(role)) {
            throw new Error(`Invalid role: ${role}`);
        }
        return role as Role;
    }
}
=====================


=====================
errors.ts
src/utils/errors.ts
=====================
export class AuthError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'AuthError';
    }
}

export class PermissionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'PermissionError';
    }
}
=====================


=====================
logger.ts
src/utils/logger.ts
=====================
export const Logger = {
    info: (message: string, ...args: any[]) => {
        console.log(`[INFO] ${message}`, ...args);
    },
    error: (message: string, ...args: any[]) => {
        console.error(`[ERROR] ${message}`, ...args);
    },
    warn: (message: string, ...args: any[]) => {
        console.warn(`[WARN] ${message}`, ...args);
    }
};
=====================


=====================
token.ts
src/utils/token.ts
=====================
// src/utils/token.ts
import { randomBytes } from 'crypto';

export function generateToken(length: number = 32): string {
    return randomBytes(length).toString('hex');
}
=====================


=====================
tsconfig.json
tsconfig.json
=====================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    "lib": ["es2020"],                                   /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
     "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
     "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./src",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    "baseUrl": ".",                                  /* Specify the base directory to resolve non-relative module names. */
    "paths": {
      "@/*": ["./src/*"]
    },
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
     "outDir": "./dist",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

=====================


