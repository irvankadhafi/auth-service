=====================
auth-service-codes.txt
auth-service-codes.txt
=====================

"auth-service-codes.txt" is not a text file (MIME type: inode/x-empty)

=====================


=====================
package-lock.json
package-lock.json
=====================

"package-lock.json" is not a text file (MIME type: application/json)

=====================


=====================
package.json
package.json
=====================

"package.json" is not a text file (MIME type: application/json)

=====================


=====================
database.ts
src/config/database.ts
=====================
import { DataSource } from 'typeorm';
import { config } from 'dotenv';

config();

export const AppDataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432'),
    username: process.env.DB_USERNAME,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    synchronize: true,
    logging: true,
    entities: ['src/domain/entities/**/*.ts'],
    migrations: ['src/infrastructure/database/migrations/**/*.ts'],
});
=====================


=====================
redis.ts
src/config/redis.ts
=====================
import Redis from 'ioredis';
import { config } from 'dotenv';

config();

export const redis = new Redis({
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || '6379'),
});
=====================


=====================
server.ts
src/console/server.ts
=====================
import { Server, ServerCredentials } from '@grpc/grpc-js';
import express from 'express';
import { ApolloServer } from 'apollo-server-express';
import { container } from 'tsyringe';
import { Config } from '../config/constants';
import { Logger } from '../utils/logger';
import { authServiceHandlers } from '../infrastructure/grpc/implementations';
import { AuthServiceService } from '../infrastructure/grpc/proto/auth_grpc_pb';
import { setupRoutes } from '../delivery/http/routes';
import { schema } from '../delivery/http/graphql/schema';
import { DataSource } from 'typeorm';
import { RedisClient } from '../infrastructure/redis/redis-client';

export class ServerConsole {
    private httpServer: express.Application;
    private grpcServer: Server;
    private apolloServer: ApolloServer;
    private isShuttingDown = false;

    constructor(
        private logger: Logger,
        private dataSource: DataSource,
        private redisClient: RedisClient
    ) {
        this.httpServer = express();
        this.grpcServer = new Server();
    }

    private async setupHttp(): Promise<void> {
        const httpPort = Config.HTTP_PORT;

        // Setup middlewares & routes
        setupRoutes(this.httpServer);

        return new Promise((resolve) => {
            const server = this.httpServer.listen(httpPort, () => {
                this.logger.info(`HTTP Server running on port ${httpPort}`);
                resolve();
            });

            // HTTP Graceful shutdown
            process.on('SIGTERM', () => {
                this.logger.info('SIGTERM received. Shutting down HTTP server...');
                server.close(() => {
                    this.logger.info('HTTP server closed');
                });
            });
        });
    }

    private async setupGraphql(): Promise<void> {
        this.apolloServer = new ApolloServer({
            schema,
            context: ({ req }) => ({
                req,
                container
            })
        });

        await this.apolloServer.start();
        this.apolloServer.applyMiddleware({ app: this.httpServer });

        this.logger.info(`GraphQL Server running at /graphql`);
    }

    private async setupGrpc(): Promise<void> {
        const grpcPort = Config.GRPC_PORT;

        // Add services
        this.grpcServer.addService(AuthServiceService, authServiceHandlers);

        return new Promise((resolve, reject) => {
            this.grpcServer.bindAsync(
                `0.0.0.0:${grpcPort}`,
                ServerCredentials.createInsecure(),
                (error, port) => {
                    if (error) {
                        reject(error);
                        return;
                    }
                    this.grpcServer.start();
                    this.logger.info(`gRPC Server running on port ${port}`);
                    resolve();
                }
            );
        });
    }

    private async gracefulShutdown(): Promise<void> {
        if (this.isShuttingDown) return;
        this.isShuttingDown = true;

        this.logger.info('Graceful shutdown initiated...');

        try {
            // Stop accepting new requests
            this.grpcServer.tryShutdown(async () => {
                this.logger.info('gRPC server shutdown complete');
            });

            // Close Apollo Server
            await this.apolloServer.stop();
            this.logger.info('GraphQL server shutdown complete');

            // Close database connections
            await this.dataSource.destroy();
            this.logger.info('Database connections closed');

            // Close Redis connections
            await this.redisClient.quit();
            this.logger.info('Redis connections closed');

            this.logger.info('Graceful shutdown completed');
            process.exit(0);
        } catch (error) {
            this.logger.error('Error during graceful shutdown:', error);
            process.exit(1);
        }
    }

    async run(): Promise<void> {
        try {
            // Initialize database connection
            await this.dataSource.initialize();
            this.logger.info('Database connection established');

            // Initialize Redis connection
            await this.redisClient.connect();
            this.logger.info('Redis connection established');

            // Setup all servers
            await Promise.all([
                this.setupHttp(),
                this.setupGraphql(),
                this.setupGrpc()
            ]);

            // Setup graceful shutdown
            process.on('SIGTERM', this.gracefulShutdown.bind(this));
            process.on('SIGINT', this.gracefulShutdown.bind(this));

            this.logger.info('All servers started successfully');
        } catch (error) {
            this.logger.error('Failed to start servers', error);
            throw error;
        }
    }
}
=====================


=====================
rbac.constants.ts
src/domain/constants/rbac.constants.ts
=====================
export const Roles = {
    SUPER_ADMIN: 'SUPER_ADMIN',
    EMPLOYEE: 'EMPLOYEE',
    USER: 'USER'
} as const;

export const Resources = {
    USER: 'user',
    EMPLOYEE: 'employee',
    DEPARTMENT: 'department',
    ATTENDANCE: 'attendance',
} as const;

export const Actions = {
    CREATE: 'create',
    READ: 'read',
    UPDATE: 'update',
    DELETE: 'delete',
    READ_ALL: 'read_all',
    UPDATE_ALL: 'update_all',
    DELETE_ALL: 'delete_all',
} as const;
=====================


=====================
action.entity.ts
src/domain/entities/action.entity.ts
=====================
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('actions')
export class Action {
    @PrimaryColumn()
    id: string;

    constructor(id: string) {
        this.id = id;
    }
}
=====================


=====================
resource.entity.ts
src/domain/entities/resource.entity.ts
=====================
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('resources')
export class Resource {
    @PrimaryColumn()
    id: string;

    constructor(id: string) {
        this.id = id;
    }
}
=====================


=====================
role-resource-action.entity.ts
src/domain/entities/role-resource-action.entity.ts
=====================
import { Entity, Column, ManyToOne, JoinColumn, Unique } from 'typeorm';
import { Resource } from './resource.entity';
import { Action } from './action.entity';

@Entity('role_resource_actions')
@Unique('rra_unique_idx', ['role', 'resource', 'action'])
export class RoleResourceAction {
    @Column({
        type: 'enum',
        enum: ['SUPER_ADMIN', 'EMPLOYEE', 'USER'],
        name: 'role'
    })
    role: string;

    @ManyToOne(() => Resource)
    @JoinColumn({ name: 'resource' })
    resource: Resource;

    @ManyToOne(() => Action)
    @JoinColumn({ name: 'action' })
    action: Action;

    constructor(role: string, resource: Resource, action: Action) {
        this.role = role;
        this.resource = resource;
        this.action = action;
    }
}
=====================


=====================
user.entity.ts
src/domain/entities/user.entity.ts
=====================
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

export type UserRole = 'SUPER_ADMIN' | 'KUMPARAN_ADMIN' | 'SPACE_ADMIN' | 'MEMBER' | 'INTERNAL_SERVICE';

@Entity('users')
export class User {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ unique: true })
    email: string;

    @Column()
    password: string;

    @Column()
    fullName: string;

    @Column({
        type: 'enum',
        enum: ['SUPER_ADMIN', 'KUMPARAN_ADMIN', 'SPACE_ADMIN', 'MEMBER', 'INTERNAL_SERVICE'],
        default: 'MEMBER'
    })
    role: UserRole;

    @CreateDateColumn()
    createdAt: Date;

    @UpdateDateColumn()
    updatedAt: Date;

    constructor(
        email: string,
        password: string,
        fullName: string,
        role: UserRole = 'MEMBER'
    ) {
        this.email = email;
        this.password = password;
        this.fullName = fullName;
        this.role = role;
        this.createdAt = new Date();
        this.updatedAt = new Date();
    }
}
=====================


=====================
rbac.repository.ts
src/domain/repositories/rbac.repository.ts
=====================
import { injectable } from 'tsyringe';
import { Repository } from 'typeorm';
import { AppDataSource } from '@/config/database';
import { RoleResourceAction } from '../entities/role-resource-action.entity';
import { Resource } from '../entities/resource.entity';
import { Action } from '../entities/action.entity';

@injectable()
export class RBACRepository {
    private rraRepository: Repository<RoleResourceAction>;
    private resourceRepository: Repository<Resource>;
    private actionRepository: Repository<Action>;

    constructor() {
        this.rraRepository = AppDataSource.getRepository(RoleResourceAction);
        this.resourceRepository = AppDataSource.getRepository(Resource);
        this.actionRepository = AppDataSource.getRepository(Action);
    }

    async createRoleResourceAction(role: string, resourceId: string, actionId: string): Promise<void> {
        const resource = await this.resourceRepository.findOneBy({ id: resourceId });
        const action = await this.actionRepository.findOneBy({ id: actionId });

        if (!resource || !action) {
            throw new Error('Resource or Action not found');
        }

        const rra = new RoleResourceAction(role, resource, action);
        await this.rraRepository.save(rra);
    }

    async getRolePermissions(role: string): Promise<RoleResourceAction[]> {
        return this.rraRepository.find({
            where: { role },
            relations: ['resource', 'action']
        });
    }

    async hasPermission(role: string, resourceId: string, actionId: string): Promise<boolean> {
        const permission = await this.rraRepository.findOne({
            where: {
                role,
                resource: { id: resourceId },
                action: { id: actionId }
            }
        });

        return !!permission;
    }
}
=====================


=====================
user.repository.ts
src/domain/repositories/user.repository.ts
=====================
// src/domain/repositories/user.repository.ts
import { injectable } from 'tsyringe';
import { Repository } from 'typeorm';
import { AppDataSource } from '@/config/database';
import { User, UserRole } from '../entities/user.entity';

@injectable()
export class UserRepository {
    private repository: Repository<User>;

    constructor() {
        this.repository = AppDataSource.getRepository(User);
    }

    async create(email: string, password: string, fullName: string, role: UserRole = 'MEMBER'): Promise<User> {
        const user = new User(email, password, fullName, role);
        return this.repository.save(user);
    }

    async findByEmail(email: string): Promise<User | null> {
        return this.repository.findOne({ where: { email } });
    }

    async findById(id: number): Promise<User | null> {
        return this.repository.findOne({ where: { id } });
    }

    async update(id: number, data: Partial<Pick<User, 'email' | 'password' | 'fullName' | 'role'>>): Promise<User | null> {
        await this.repository.update(id, data);
        return this.findById(id);
    }
}
=====================


=====================
tsconfig.json
tsconfig.json
=====================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    "lib": ["es2020"],                                   /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
     "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
     "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./src",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    "baseUrl": ".",                                  /* Specify the base directory to resolve non-relative module names. */
    "paths": {
      "@/*": ["./src/*"]
    },
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
     "outDir": "./dist",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

=====================


