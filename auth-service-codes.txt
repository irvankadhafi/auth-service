=====================
1736984296392-create-user.ts
db/migrations/1736984296392-create-user.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateUser1736984296392 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TYPE user_role AS ENUM ('ADMIN', 'MANAGER', 'EMPLOYEE');
            
            CREATE TABLE IF NOT EXISTS "users" (
                "id" SERIAL PRIMARY KEY,
                "email" VARCHAR(255) UNIQUE NOT NULL,
                "password" VARCHAR(255) NOT NULL,
                "role" user_role NOT NULL,
                "created_at" timestamp NOT NULL DEFAULT 'now()',
                "updated_at" timestamp NOT NULL DEFAULT 'now()',
                "deleted_at" timestamp
            );
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "users";
        `);
    }
}

=====================


=====================
1736984315673-create-sessions.ts
db/migrations/1736984315673-create-sessions.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateSessions1736984315673 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TABLE IF NOT EXISTS "sessions" (
                "id" SERIAL PRIMARY KEY,
                "user_id" INTEGER NOT NULL,
                "access_token" VARCHAR(255) UNIQUE NOT NULL,
                "refresh_token" VARCHAR(255) UNIQUE NOT NULL,
                "access_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
                "refresh_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
                "user_agent" VARCHAR(255),
                "latitude" VARCHAR(50),
                "longitude" VARCHAR(50),
                "ip_address" VARCHAR(50),
                "created_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY ("user_id") REFERENCES "users" ("id")
            );
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "sessions";
        `);
    }
}

=====================


=====================
1736984319024-create-rbac.ts
db/migrations/1736984319024-create-rbac.ts
=====================
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateRbac1736984319024 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your UP migration SQL here
            CREATE TABLE IF NOT EXISTS "resources" (
                "id" TEXT PRIMARY KEY
            );
            
            CREATE TABLE IF NOT EXISTS "actions" (
                "id" TEXT PRIMARY KEY
            );
            
            CREATE TABLE IF NOT EXISTS "role_resource_actions" (
                "role" user_role NOT NULL,
                "resource" TEXT NOT NULL REFERENCES "resources"(id),
                "action" TEXT NOT NULL REFERENCES "actions"(id)
            );
            
            CREATE UNIQUE INDEX rra_unique_idx ON "role_resource_actions"("role", "resource", "action");
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            -- Write your DOWN migration SQL here
            DROP TABLE IF EXISTS "role_resource_actions";
            DROP TABLE IF EXISTS "actions";
            DROP TABLE IF EXISTS "resources";
            DROP TYPE IF EXISTS action_type;
            DROP TYPE IF EXISTS resource_type;
            DROP TYPE IF EXISTS user_role;
        `);
    }
}

=====================


=====================
package-lock.json
package-lock.json
=====================

"package-lock.json" is not a text file (MIME type: application/json)

=====================


=====================
package.json
package.json
=====================

"package.json" is not a text file (MIME type: application/json)

=====================


=====================
auth.proto
proto/auth.proto
=====================

"auth.proto" is not a text file (MIME type: cannot open `proto/auth.proto' (No such file or directory))

=====================


=====================
database.ts
src/config/database.ts
=====================
import { DataSourceOptions } from 'typeorm';
import { Config } from './index';

export const databaseConfig: DataSourceOptions = {
    type: 'postgres',
    url: Config.DATABASE_URL,
    entities: ['src/domain/entities/*.entity.ts'],
    migrations: ['db/migrations/*.ts'],
    migrationsTableName: 'schema_migrations',
    synchronize: false,
    logging: true
};
=====================


=====================
index.ts
src/config/index.ts
=====================
import dotenv from 'dotenv';

dotenv.config();

export class Config {
    static get NODE_ENV(): string {
        return process.env.NODE_ENV || 'development';
    }

    static get DATABASE_URL(): string {
        return process.env.DATABASE_URL || 'postgresql://auth_user:auth123@localhost:5432/auth_db';
    }

    static get REDIS_URL(): string {
        return process.env.REDIS_URL || 'redis://localhost:6379';
    }

    static get HTTP_PORT(): number {
        return parseInt(process.env.HTTP_PORT || '3000');
    }

    static get GRPC_PORT(): number {
        return parseInt(process.env.GRPC_PORT || '50051');
    }

    static get JWT_SECRET(): string {
        return process.env.JWT_SECRET || 'your-secret-key';
    }
}
=====================


=====================
redis.ts
src/config/redis.ts
=====================
import Redis from 'ioredis';
import { config } from 'dotenv';

config();

export const redis = new Redis({
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || '6379'),
});
=====================


=====================
create-migration.ts
src/console/create-migration.ts
=====================
// src/console/create-migration.ts
import { Command } from 'commander';
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { Logger } from '@/utils/logger';

export const createMigrationCommand = new Command('create:migration')
    .description('Create a new migration file')
    .argument('<name>', 'migration name')
    .action((name: string) => {
        try {
            // Generate timestamp
            const timestamp = Date.now();

            // Convert name to PascalCase
            const className = name
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join('');

            const migrationContent = `import { MigrationInterface, QueryRunner } from "typeorm";

export class ${className}${timestamp} implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(\`
            -- Write your UP migration SQL here
        \`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(\`
            -- Write your DOWN migration SQL here
        \`);
    }
}
`;

            const migrationsDir = join(process.cwd(), 'db', 'migrations');
            mkdirSync(migrationsDir, { recursive: true });

            const fileName = `${timestamp}-${name}.ts`;
            const filePath = join(migrationsDir, fileName);

            writeFileSync(filePath, migrationContent);
            Logger.info(`Created migration file: ${fileName}`);

            // Tambahkan instruksi untuk pengguna
            Logger.info('\nNext steps:');
            Logger.info('1. Open the generated migration file');
            Logger.info('2. Replace the SQL placeholders with your actual migration SQL');
            Logger.info('3. Run the migration with: npm run migrate');
        } catch (error) {
            Logger.error('Failed to create migration:', error);
            process.exit(1);
        }
    });
=====================


=====================
migrate-rbac.ts
src/console/migrate-rbac.ts
=====================
// src/console/migrate-rbac.ts
import { Command } from 'commander';
import { container } from 'tsyringe';
import { Logger } from '@/utils/logger';
import { Role, DEFAULT_RESOURCES, DEFAULT_ACTIONS } from '@/utils/constants';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { DataSource } from 'typeorm';
import { Config } from '@/config';
import Redis from 'ioredis';
import { setupContainer } from './server';

export const migrateRBACCommand = new Command('migrate:rbac')
    .description('Migrate RBAC default permissions')
    .action(async () => {
        try {
            Logger.info('Starting RBAC migration...');

            // Initialize database connection
            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                synchronize: false,
                logging: true
            });

            await dataSource.initialize();
            Logger.info('Database connected successfully');

            // Initialize Redis
            const redis = new Redis(Config.REDIS_URL);
            Logger.info('Redis connected successfully');

            // Setup dependency injection
            await setupContainer(dataSource, redis);

            // Resolve RBACRepository
            const rbacRepo = container.resolve<RBACRepository>('RBACRepository');

            // Create resources
            Logger.info('Creating resources...');
            for (const resource of Object.values(DEFAULT_RESOURCES)) {
                await rbacRepo.createResource(resource);
                Logger.info(`Created resource: ${resource}`);
            }

            // Create actions
            Logger.info('Creating actions...');
            for (const action of Object.values(DEFAULT_ACTIONS)) {
                await rbacRepo.createAction(action);
                Logger.info(`Created action: ${action}`);
            }

            // Create default permissions
            Logger.info('Creating role-resource-action mappings...');

            // Admin permissions (all access)
            for (const resource of Object.values(DEFAULT_RESOURCES)) {
                for (const action of Object.values(DEFAULT_ACTIONS)) {
                    await rbacRepo.createRoleResourceAction(Role.ADMIN, resource, action);
                    Logger.info(`Created permission: ${Role.ADMIN} - ${resource} - ${action}`);
                }
            }

            // Manager permissions
            const managerPermissions = [
                { resource: DEFAULT_RESOURCES.EMPLOYEE, action: DEFAULT_ACTIONS.READ },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.APPROVE },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.REJECT },
                { resource: DEFAULT_RESOURCES.REPORT, action: DEFAULT_ACTIONS.READ }
            ];

            for (const perm of managerPermissions) {
                await rbacRepo.createRoleResourceAction(Role.MANAGER, perm.resource, perm.action);
                Logger.info(`Created permission: ${Role.MANAGER} - ${perm.resource} - ${perm.action}`);
            }

            // Employee permissions
            const employeePermissions = [
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.SUBMIT },
                { resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ }
            ];

            for (const perm of employeePermissions) {
                await rbacRepo.createRoleResourceAction(Role.EMPLOYEE, perm.resource, perm.action);
                Logger.info(`Created permission: ${Role.EMPLOYEE} - ${perm.resource} - ${perm.action}`);
            }

            Logger.info('RBAC migration completed successfully!');

            // Cleanup connections
            await redis.quit();
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('RBAC migration failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
migrate.ts
src/console/migrate.ts
=====================
// src/console/migrate.ts
import { Command } from 'commander';
import { DataSource } from 'typeorm';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';

export const migrateCommand = new Command('migrate')
    .description('Database migration command')
    .option('--step <number>', 'maximum migration steps', '0')
    .option('--direction <string>', 'migration direction (up/down)', 'up')
    .action(async (options) => {
        try {
            const direction = options.direction;
            const step = parseInt(options.step);

            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                migrations: ['db/migrations/*.ts'],
                migrationsTableName: 'schema_migrations'
            });

            await dataSource.initialize();
            Logger.info('Database connected');

            if (direction === 'down') {
                if (step > 0) {
                    Logger.info(`Rolling back ${step} migration(s)...`);
                    for (let i = 0; i < step; i++) {
                        await dataSource.undoLastMigration();
                    }
                } else {
                    Logger.info('Rolling back last migration...');
                    await dataSource.undoLastMigration();
                }
            } else {
                Logger.info('Running pending migrations...');
                await dataSource.runMigrations();
            }

            Logger.info('Migrations completed successfully!');
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('Migration failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
server.ts
src/console/server.ts
=====================
// src/console/server.ts
import express from 'express';
import { createServer } from 'http';
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import Redis from 'ioredis';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';
import { setupRoutes } from '@/delivery/http/routes';
import { GrpcServer } from '@/delivery/grpc/server';

// Repositories
import { UserRepositoryImpl } from '@/repository/user.repository';
import { SessionRepositoryImpl } from '@/repository/session.repository';
import { RBACRepositoryImpl } from '@/repository/rbac.repository';

// Use Cases
import {SessionRepository} from "@/domain/repositories/session.repository";
import {UserRepository} from "@/domain/repositories/user.repository";
import {RBACRepository} from "@/domain/repositories/rbac.repository";
import {AuthUseCase} from "@/domain/usecases/auth.usecase";
import {AuthUseCaseImpl} from "@/usecase/auth.usecase";
import {UserUseCase} from "@/domain/usecases/user.usecase";
import {UserUsecaseImpl} from "@/usecase/user.usecase";

export class Server {
    private httpServer: express.Application;
    private grpcServer: GrpcServer;
    private dataSource!: DataSource;
    private redis!: Redis;
    private logger: typeof Logger;

    constructor() {
        this.httpServer = express();
        this.grpcServer = new GrpcServer();
        this.logger = Logger;
    }

    async initialize(): Promise<void> {
        await this.setupDatabase();
        await this.setupRedis();
        await setupContainer(this.dataSource, this.redis); // Use the shared setup function
        // await this.setupDependencyInjection();
    }

    private async setupDatabase(): Promise<void> {
        this.dataSource = new DataSource({
            type: 'postgres',
            url: Config.DATABASE_URL,
            entities: ['src/domain/entities/*.entity.ts'],
            synchronize: false,
            logging: true
        });

        await this.dataSource.initialize();
        this.logger.info('Database connected successfully');
    }

    private async setupRedis(): Promise<void> {
        this.redis = new Redis(Config.REDIS_URL);
        this.logger.info('Redis connected successfully');
    }

    private async setupGrpc(): Promise<void> {
        await this.grpcServer.start();
    }

    async start(): Promise<void> {
        await this.initialize();

        // Setup delivery methods
        await Promise.all([
            this.setupHttp(),
            // this.setupGraphQL(),
            this.setupGrpc()
        ]);

        this.setupGracefulShutdown();
    }

    private async setupHttp(): Promise<void> {
        const httpPort = Config.HTTP_PORT;

        this.httpServer.use(express.json());
        setupRoutes(this.httpServer);

        return new Promise((resolve) => {
            const server = this.httpServer.listen(httpPort, () => {
                this.logger.info(`HTTP Server running on port ${httpPort}`);
                resolve();
            });

            // HTTP Graceful shutdown
            process.on('SIGTERM', () => {
                this.logger.info('SIGTERM received. Shutting down HTTP server...');
                server.close(() => {
                    this.logger.info('HTTP server closed');
                });
            });
        });
    }

    private setupGracefulShutdown(): void {
        const shutdown = async () => {
            this.logger.info('Shutting down...');

            try {
                await this.redis.quit();
                await this.dataSource.destroy();
                this.logger.info('Connections closed');
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during shutdown:', error);
                process.exit(1);
            }
        };

        process.on('SIGTERM', shutdown);
        process.on('SIGINT', shutdown);
    }
}

export async function setupContainer(dataSource: DataSource, redis: Redis): Promise<void> {
    // Reset container
    container.reset();

    // Register instances
    container.registerInstance('DataSource', dataSource);
    container.registerInstance('Redis', redis);
    container.registerInstance('Logger', Logger);

    // Register repositories as singletons
    container.registerSingleton<SessionRepository>('SessionRepository', SessionRepositoryImpl);
    container.registerSingleton<UserRepository>('UserRepository', UserRepositoryImpl);
    container.registerSingleton<RBACRepository>('RBACRepository', RBACRepositoryImpl);
    container.registerSingleton<AuthUseCase>('AuthUseCase', AuthUseCaseImpl);
    container.registerSingleton<UserUseCase>('UserUseCase', UserUsecaseImpl);

    // Debug logs
    console.log('Container setup completed. Registrations:', {
        dataSource: container.isRegistered('DataSource'),
        redis: container.isRegistered('Redis'),
        sessionRepo: container.isRegistered('SessionRepository'),
        authUseCase: container.isRegistered('AuthUseCase')
    });
}
=====================


=====================
user.seeder.ts
src/console/user.seeder.ts
=====================
// src/console/user.seeder.ts
import 'reflect-metadata'; // Tambahkan ini di baris paling atas
import { Command } from 'commander';
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';
import { Role } from '@/utils/constants';
import { UserRepository } from '@/domain/repositories/user.repository';
import { UserRepositoryImpl } from '@/repository/user.repository';
import { User } from '@/domain/entities/user.entity';
import bcrypt from 'bcrypt';
import { setupContainer } from './server';
import Redis from 'ioredis';

export const userSeederCommand = new Command('seed:user')
    .description('Seed default users for testing')
    .action(async () => {
        console.log('userSeederCommand is running...'); // Tambahkan ini
        try {
            Logger.info('Starting user seeder...');

            // Initialize database connection
            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                synchronize: false,
                logging: true
            });

            await dataSource.initialize();
            Logger.info('Database connected successfully');

            // Initialize Redis
            const redis = new Redis(Config.REDIS_URL);
            Logger.info('Redis connected successfully');

            // Setup dependency injection
            await setupContainer(dataSource, redis);

            // Resolve UserRepository
            const userRepo = container.resolve<UserRepository>('UserRepository');

            // Define users to seed
            const usersToSeed = [
                {
                    email: 'admin@example.com',
                    password: 'password123',
                    role: Role.ADMIN
                },
                {
                    email: 'manager@example.com',
                    password: 'password123',
                    role: Role.MANAGER
                },
                {
                    email: 'employee@example.com',
                    password: 'password123',
                    role: Role.EMPLOYEE
                }
            ];

            // Seed users
            for (const userData of usersToSeed) {
                // const hashedPassword = await bcrypt.hash(userData.password, 10);
                const user = new User();
                user.email = userData.email;
                user.password = userData.password;
                user.role = userData.role;

                try {
                    await userRepo.create(user);
                    Logger.info(`Seeded user: ${userData.email} with role: ${userData.role}`);
                } catch (error) {
                    Logger.warn(`User ${userData.email} might already exist:`, error);
                }
            }

            Logger.info('User seeder completed successfully!');

            // Cleanup connections
            await redis.quit();
            await dataSource.destroy();
            process.exit(0);
        } catch (error) {
            Logger.error('User seeder failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
auth.handler.ts
src/delivery/grpc/handlers/auth.handler.ts
=====================
import { ServerUnaryCall, sendUnaryData } from '@grpc/grpc-js';
import {inject, injectable} from 'tsyringe';
import { UserRepository } from '@/domain/repositories/user.repository';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { Logger } from '@/utils/logger';
import { EnumHelper } from '@/utils/enum-helper';
import { AuthUseCase, UserUseCase } from "@/domain/usecases";
import {User} from "@/proto/user_pb";
import {
    AuthenticateAccessTokenRequest,
    AuthenticateAccessTokenResponse,
    FindByIdRequest,
    FindRolePermissionRequest, Permission
} from "@/proto/auth_service_pb";
import { RolePermission as ProtoRolePermission } from "@/proto/auth_service_pb";
import {RolePermission} from "@/rbac/role-permission";

@injectable()
export class AuthGrpcHandler {
    constructor(
        @inject('AuthUseCase') private readonly authUseCase: AuthUseCase,
        @inject('UserUseCase') private userUseCase: UserUseCase,
        @inject('UserRepository') private userRepo: UserRepository,
        @inject('RBACRepository') private rbacRepo: RBACRepository
    ) {
        console.log('AuthGrpcHandler constructed with:', {
            authUseCase: !!authUseCase,
            userRepo: !!userRepo,
            rbacRepo: !!rbacRepo
        });
    }

    async findUserByID(
        call: ServerUnaryCall<FindByIdRequest, User>,
        callback: sendUnaryData<User>
    ): Promise<void> {
        try {
            const request = call.request as FindByIdRequest;
            const user = await this.userUseCase.findById(request.getId());
            if (!user) {
                callback({
                    code: 5, // NOT_FOUND
                    message: 'User not found'
                });
                return;
            }

            const protoUser = new User();
            protoUser.setId(user.id);
            protoUser.setEmail(user.email);
            protoUser.setRole(user.role);
            const createdAt = user.createdAt instanceof Date ? user.createdAt : new Date(user.createdAt);
            const updatedAt = user.updatedAt instanceof Date ? user.updatedAt : new Date(user.updatedAt);

            protoUser.setCreatedAt(createdAt.toISOString());
            protoUser.setUpdatedAt(updatedAt.toISOString());

            // Kirim response
            callback(null, protoUser);
        } catch (error) {
            Logger.error('Error in findUserByID:', error);
            callback({
                code: 13,
                message: 'Internal server error'
            });
        }
    }

    async authenticateAccessToken(
        call: ServerUnaryCall<AuthenticateAccessTokenRequest, AuthenticateAccessTokenResponse>,
        callback: sendUnaryData<AuthenticateAccessTokenResponse>
    ): Promise<void> {
        try {
            // Menggunakan access_token sesuai dengan definisi proto
            const user = await this.authUseCase.validateToken(call.request.getAccessToken());
            if (!user) {
                callback({
                    code: 5, // NOT_FOUND
                    message: 'User not found'
                });
                return;
            }

            const protoUser = new User();
            protoUser.setId(user.id);
            protoUser.setEmail(user.email);
            protoUser.setRole(user.role);
            const createdAt = user.createdAt instanceof Date ? user.createdAt : new Date(user.createdAt);
            const updatedAt = user.updatedAt instanceof Date ? user.updatedAt : new Date(user.updatedAt);

            protoUser.setCreatedAt(createdAt.toISOString());
            protoUser.setUpdatedAt(updatedAt.toISOString());

            const response = new AuthenticateAccessTokenResponse();
            response.setUser(protoUser);


            const rolePermission = user.getRolePermission();
            if (!rolePermission) {
                callback({
                    code: 13, // INTERNAL
                    message: 'Role permission not found'
                });
                return;
            }

            const protoRolePermission = new ProtoRolePermission();
            protoRolePermission.setRole(user.role);

            rolePermission.permissions.forEach(perm => {
                const protoPermission = new Permission();
                protoPermission.setResource(perm.resource);
                protoPermission.setAction(perm.action);
                protoRolePermission.addPermissions(protoPermission);
            });

            response.setRolePermission(protoRolePermission);

            // Format response sesuai dengan message User di proto
            callback(null, response);
        } catch (error) {
            Logger.error('Error in authenticateAccessToken:', error);
            callback({
                code: 16, // UNAUTHENTICATED
                message: 'Invalid token'
            });
        }
    }

    async findRolePermission(
        call: ServerUnaryCall<FindRolePermissionRequest, RolePermission>,
        callback: sendUnaryData<any>
    ): Promise<void> {
        try {
            const role = EnumHelper.toRole(call.request.getRole());
            const permissions = await this.rbacRepo.loadPermission();
            const rolePermissions = permissions.RRA.get(role);

            if (!rolePermissions) {
                callback({
                    code: 5,
                    message: 'Permissions not found for role'
                });
                return;
            }

            callback(null, {
                role: role,
                permissions: rolePermissions
            });
        } catch (error) {
            Logger.error('Error in findRolePermission:', error);
            callback({
                code: 13,
                message: 'Internal server error'
            });
        }
    }
}
=====================


=====================
internalServiceInterceptor.ts
src/delivery/grpc/interceptors/internalServiceInterceptor.ts
=====================
// src/delivery/grpc/interceptors/internalServiceInterceptor.ts
import * as grpc from '@grpc/grpc-js';
import { Context } from '@/utils/context';
import { User } from '@/domain/entities/user.entity';
import { Role } from '@/utils/constants';

export const internalServiceInterceptor = (
    handler: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => void
) => {
    return (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => {
        const metadata = call.metadata;

        // Cek apakah permintaan berasal dari internal service
        const isInternalService = metadata.get('x-internal-service').includes('true');

        if (isInternalService) {
            // Buat instance User untuk internal service
            const internalServiceUser = new User();
            internalServiceUser.id = 0; // User ID khusus untuk internal service
            internalServiceUser.role = Role.INTERNAL_SERVICE;

            // Set user di context
            Context.run({ user: internalServiceUser }, () => {
                // Lanjutkan ke handler
                handler(call, callback);
            });
        } else {
            // Lanjutkan tanpa mengubah context
            handler(call, callback);
        }
    };
};
=====================


=====================
loggingInterceptor.ts
src/delivery/grpc/interceptors/loggingInterceptor.ts
=====================
import * as grpc from '@grpc/grpc-js';

export const loggingInterceptor = (
    handler: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => void
) => {
    return (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => {
        console.log(`Received request for method: ${call.getPath()}`);
        handler(call, callback);
    };
};
=====================


=====================
server.ts
src/delivery/grpc/server.ts
=====================
// src/delivery/grpc/server.ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import { container } from 'tsyringe';
import { join } from 'path';
import { Logger } from '@/utils/logger';
import { AuthGrpcHandler } from './handlers/auth.handler';
import { Config } from '@/config';
import {wrapHandler} from "@/delivery/grpc/utils/handlerWrapper";

import { AuthServiceService, IAuthServiceServer } from '@/proto/auth_service_grpc_pb';

import {
    FindByIdRequest,
    AuthenticateAccessTokenRequest,
    FindRolePermissionRequest,
    RolePermission, AuthenticateAccessTokenResponse,
} from '@/proto/auth_service_pb';

import {
    CreateUserRequest, FindUserByEmailRequest,
    User
} from '@/proto/user_pb';

export class GrpcServer {
    private server: grpc.Server;
    private authHandler: AuthGrpcHandler;

    constructor() {
        this.server = new grpc.Server();
        this.authHandler = container.resolve(AuthGrpcHandler);

        console.log('Container registrations:', {
            sessionRepo: container.isRegistered('SessionRepository'),
            authUseCase: container.isRegistered('AuthUseCase')
        });
    }

    async initialize() {
        // Resolve handler after container setup
        this.authHandler = container.resolve(AuthGrpcHandler);

        console.log('GrpcServer initialized with:', {
            authHandler: !!this.authHandler,
            authUseCase: container.isRegistered('AuthUseCase'),
            sessionRepo: container.isRegistered('SessionRepository')
        });
    }

    async start(): Promise<void> {
        await this.initialize();

        // Implementasi service
        const serviceImplementation: IAuthServiceServer = {
            findUserById: wrapHandler(
                (call: grpc.ServerUnaryCall<FindByIdRequest, User>, callback: grpc.sendUnaryData<User>) => {
                    console.log('findUserById called with request:', call.request);
                    return this.authHandler.findUserByID(call, callback);
                }
            ),
            createUser: wrapHandler(
                (call: grpc.ServerUnaryCall<CreateUserRequest, User>, callback: grpc.sendUnaryData<User>) => {
                    console.log('createUser called with request:', call.request);
                    // return this.authHandler.createUser(call, callback);
                }
            ),
            findUserByEmail: wrapHandler(
                (call: grpc.ServerUnaryCall<FindUserByEmailRequest, User>, callback: grpc.sendUnaryData<User>) => {
                    console.log('findUserByEmail called with request:', call.request);
                    // return this.authHandler.findUserByEmail(call, callback);
                }
            ),
            authenticateAccessToken: wrapHandler(
                (
                    call: grpc.ServerUnaryCall<AuthenticateAccessTokenRequest, AuthenticateAccessTokenResponse>,
                    callback: grpc.sendUnaryData<AuthenticateAccessTokenResponse>
                ) => {
                    return this.authHandler.authenticateAccessToken(call, callback);
                }
            ),
            findRolePermission: wrapHandler(
                (
                    call: grpc.ServerUnaryCall<FindRolePermissionRequest, RolePermission>,
                    callback: grpc.sendUnaryData<RolePermission>
                ) => {
                    return this.authHandler.findRolePermission(call, callback);
                }
            ),
        };
        //
        // // Load file proto
        // const packageDefinition = protoLoader.loadSync(
        //     join(__dirname, '../../../proto/auth_service.proto'),
        //     {
        //         keepCase: true,
        //         longs: String,
        //         enums: String,
        //         defaults: true,
        //         oneofs: true,
        //     }
        // );
        //
        // const proto = grpc.loadPackageDefinition(packageDefinition);
        //
        // // Debug logging untuk melihat service definition
        // console.log('Loaded proto service methods:', Object.keys((proto as any).auth.AuthService.service));

        // Tambahkan service ke server
        this.server.addService(
            AuthServiceService,
            serviceImplementation
        );



        return new Promise((resolve, reject) => {
            const address = `0.0.0.0:${Config.GRPC_PORT}`;
            this.server.bindAsync(
                address,
                grpc.ServerCredentials.createInsecure(),
                (error, port) => {
                    if (error) {
                        Logger.error('Failed to start gRPC server:', error);
                        reject(error);
                        return;
                    }
                    this.server.start();
                    Logger.info(`gRPC Server listening on ${address}`);
                    resolve();
                }
            );
        });
    }

    async stop(): Promise<void> {
        return new Promise((resolve) => {
            this.server.tryShutdown(() => {
                Logger.info('gRPC Server shutdown complete');
                resolve();
            });
        });
    }
}
=====================


=====================
handlerWrapper.ts
src/delivery/grpc/utils/handlerWrapper.ts
=====================
// src/delivery/grpc/utils/handlerWrapper.ts
import * as grpc from '@grpc/grpc-js';
import { internalServiceInterceptor } from '../interceptors/internalServiceInterceptor';
import {loggingInterceptor} from "@/delivery/grpc/interceptors/loggingInterceptor";

export const wrapHandler = (
    handler: (call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>) => void
) => {
    return internalServiceInterceptor(loggingInterceptor(handler));
};
=====================


=====================
auth.handler.ts
src/delivery/http/handlers/auth.handler.ts
=====================
// src/delivery/http/handlers/auth.handler.ts
import { Request, Response } from 'express';
import {inject, injectable} from 'tsyringe';
import { AuthError } from '@/utils/errors';
import { Logger } from '@/utils/logger';
import {AuthUseCase} from "@/domain/usecases/auth.usecase";

@injectable()
export class AuthHandler {
    constructor(
        @inject('AuthUseCase') private authUseCase: AuthUseCase
    ) {}

    async login(req: Request, res: Response): Promise<void> {
        try {
            const { email, password } = req.body;
            const userAgent = req.headers['user-agent'] || '';
            const ipAddress = req.ip || '';

            // Get location from headers or set default
            const latitude = req.headers['x-latitude'] as string || '0';
            const longitude = req.headers['x-longitude'] as string || '0';

            const session = await this.authUseCase.login({
                email,
                password,
                userAgent,
                ipAddress,
                latitude,
                longitude
            });

            res.status(200).json({
                status: 'success',
                data: {
                    accessToken: session.accessToken,
                    refreshToken: session.refreshToken,
                    expiresIn: session.expiresIn,
                    tokenType: 'Bearer'
                }
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during login:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }

    async logout(req: Request, res: Response): Promise<void> {
        try {
            const token = req.headers.authorization?.split(' ')[1];
            if (!token) {
                res.status(400).json({
                    status: 'error',
                    message: 'Token is required'
                });
                return;
            }

            await this.authUseCase.logout(token);

            res.status(200).json({
                status: 'success',
                message: 'Logged out successfully'
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during logout:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }

    async refreshToken(req: Request, res: Response): Promise<void> {
        try {
            const { refreshToken } = req.body;
            if (!refreshToken) {
                res.status(400).json({
                    status: 'error',
                    message: 'Refresh token is required'
                });
                return;
            }

            const session = await this.authUseCase.refreshToken(refreshToken);

            res.status(200).json({
                status: 'success',
                data: {
                    accessToken: session.accessToken,
                    refreshToken: session.refreshToken,
                    expiresIn: session.expiresIn,
                    tokenType: 'Bearer'
                }
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            Logger.error('Error during refresh token:', error);
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
}
=====================


=====================
user.handler.ts
src/delivery/http/handlers/user.handler.ts
=====================
import {NextFunction, Request, Response} from 'express';
import {inject, injectable} from 'tsyringe';
import {UserUseCase} from "@/domain/usecases/user.usecase";

@injectable()
export class UserHandler {
    constructor(
        @inject('UserUseCase') private userUseCase: UserUseCase
    ) {}


    async findUserById(req: Request, res: Response, next: NextFunction): Promise<void> {
        try {
            const userId = parseInt(req.params.id, 10);
            const user = await this.userUseCase.findById(userId);

            res.status(200).json({
                status: 'success',
                data: {
                    user: user
                }
            });
        } catch (error) {
            next(error);
        }
    }
}
=====================


=====================
auth.middleware.ts
src/delivery/http/middlewares/auth.middleware.ts
=====================
// src/delivery/http/middlewares/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { container } from 'tsyringe';
import { AuthUseCase } from '@/domain/usecases/auth.usecase';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { Context } from '@/utils/context';
import { AppError, AuthError } from '@/utils/errors';
import { User } from '@/domain/entities/user.entity';
import { Role } from '@/utils/constants';

export const authMiddleware = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        if (!token) {
            throw new AppError('No token provided', 401);
        }

        const authUseCase = container.resolve<AuthUseCase>('AuthUseCase');
        const rbacRepo = container.resolve<RBACRepository>('RBACRepository');

        // Validasi token dan dapatkan user data
        const tokenData = await authUseCase.validateToken(token);

        // Simpan ke AsyncLocalStorage
        Context.run({ user: tokenData }, next);
    } catch (error) {
       next(error);
    }
};
=====================


=====================
error.handler.ts
src/delivery/http/middlewares/error.handler.ts
=====================
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';
import { AppError, AuthError, PermissionError } from '@/utils/errors';

export const errorHandler = (
    err: Error,
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.error('Error handling request:', {
        message: err.message,
        stack: err.stack,
        path: req.path,
        method: req.method,
    });

    // Menggunakan switch case untuk menangani berbagai jenis error
    switch (true) {
        case err instanceof AuthError:
            res.status(401).json({
                status: 'error',
                message: err.message,
            });
            break;

        case err instanceof AppError:
            res.status(err.statusCode).json({
                status: 'error',
                message: err.message,
            });
            break;

        case err instanceof PermissionError:
            res.status(401).json({
                status: 'error',
                message: err.message,
            });
            break;

        default:
            // Tangani error lainnya sebagai error internal
            res.status(500).json({
                status: 'error',
                message: 'Internal server error',
            });
            break;
    }
};
=====================


=====================
request.logger.ts
src/delivery/http/middlewares/request.logger.ts
=====================
// src/delivery/http/middlewares/request.logger.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';

export const requestLogger = (
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.info(`${req.method} ${req.path}`, {
        body: req.body,
        query: req.query,
        ip: req.ip,
        userAgent: req.headers['user-agent']
    });
    next();
};
=====================


=====================
auth.validator.ts
src/delivery/http/middlewares/validators/auth.validator.ts
=====================
// src/delivery/http/middlewares/validators/auth.validator.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';

const loginSchema = Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required()
});

const refreshTokenSchema = Joi.object({
    refreshToken: Joi.string().required()
});

export const validateLoginRequest = async (
    req: Request,
    res: Response,
    next: NextFunction
): Promise<void> => {
    try {
        await loginSchema.validateAsync(req.body);
        next();
    } catch (error) {
        if (error instanceof Joi.ValidationError) {
            res.status(400).json({
                status: 'error',
                message: 'Invalid request data',
                errors: error.details // TypeScript sekarang tahu bahwa `error.details` ada
            });
        } else {
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
};

export const validateRefreshTokenRequest = async (
    req: Request,
    res: Response,
    next: NextFunction
): Promise<void> => {
    try {
        await refreshTokenSchema.validateAsync(req.body);
        next();
    } catch (error) {
        if (error instanceof Joi.ValidationError) {
            res.status(400).json({
                status: 'error',
                message: 'Invalid request data',
                errors: error.details // Sama seperti di atas
            });
        } else {
            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
};
=====================


=====================
auth.route.ts
src/delivery/http/routes/auth.route.ts
=====================
// src/delivery/http/routes/auth.route.ts
import { Router } from 'express';
import { container } from 'tsyringe';
import { AuthHandler } from '../handlers/auth.handler';
import { validateLoginRequest, validateRefreshTokenRequest } from '../middlewares/validators/auth.validator';

export const authRouter = Router();

// Delay resolving AuthHandler until the container is ready
const getAuthHandler = () => container.resolve(AuthHandler);

authRouter.post('/login', validateLoginRequest, (req, res) => getAuthHandler().login(req, res));
authRouter.post('/logout', (req, res) => getAuthHandler().logout(req, res));
authRouter.post('/refresh-token', validateRefreshTokenRequest, (req, res) => getAuthHandler().refreshToken(req, res));
=====================


=====================
index.ts
src/delivery/http/routes/index.ts
=====================
// src/delivery/http/routes/index.ts
import { Router } from 'express';
import { authRouter } from './auth.route';
import { userRouter } from './user.route';
import { errorHandler } from '../middlewares/error.handler';
import { requestLogger } from '../middlewares/request.logger';

export const setupRoutes = (app: Router): void => {
    // Middlewares
    app.use(requestLogger);

    // Routes
    app.use('/api/v1/auth', authRouter);
    app.use('/api/v1/user', userRouter);

    // Error Handler
    app.use(errorHandler);
};
=====================


=====================
user.route.ts
src/delivery/http/routes/user.route.ts
=====================
import { Router } from 'express';
import { container } from 'tsyringe';
import { UserHandler } from '../handlers/user.handler';
import { authMiddleware} from "@/delivery/http/middlewares/auth.middleware";

export const userRouter = Router();

// Delay resolving UserHandler until the container is ready
const getUserHandler = () => container.resolve(UserHandler);

userRouter.get('/:id', authMiddleware, (req, res,next) => getUserHandler().findUserById(req, res,next));
=====================


=====================
action.entity.ts
src/domain/entities/action.entity.ts
=====================
// src/domain/entities/action.entity.ts
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('actions')
export class Action {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
resource.entity.ts
src/domain/entities/resource.entity.ts
=====================
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('resources')
export class Resource {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
roleResourceAction.entity.ts
src/domain/entities/roleResourceAction.entity.ts
=====================
import { Entity, Column, PrimaryColumn, ManyToOne, JoinColumn } from 'typeorm';
import { Role } from '@/utils/constants';
import { Resource } from './resource.entity';
import { Action } from './action.entity';

@Entity('role_resource_actions')
export class RoleResourceAction {
    @PrimaryColumn({
        type: 'enum',
        enum: Role
    })
    role!: Role;

    @PrimaryColumn()
    resource!: string;

    @PrimaryColumn()
    action!: string;

    @ManyToOne(() => Resource)
    @JoinColumn({ name: 'resource' })
    resourceRef!: Resource;

    @ManyToOne(() => Action)
    @JoinColumn({ name: 'action' })
    actionRef!: Action;
}
=====================


=====================
session.entity.ts
src/domain/entities/session.entity.ts
=====================
// src/domain/entities/session.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import {Role} from "@/utils/constants";

@Entity('sessions')
export class Session {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ name: 'user_id' })
    userId!: number;

    @Column({ name: 'access_token', unique: true })
    accessToken!: string;

    @Column({ name: 'refresh_token', unique: true })
    refreshToken!: string;

    @Column({ name: 'access_token_expired_at' })
    accessTokenExpiredAt!: Date;

    @Column({ name: 'refresh_token_expired_at' })
    refreshTokenExpiredAt!: Date;

    @Column({ name: 'user_agent' })
    userAgent!: string;

    @Column()
    latitude!: string;

    @Column()
    longitude!: string;

    @Column({ name: 'ip_address' })
    ipAddress!: string;

    @CreateDateColumn({ name: 'created_at' }) // Sesuaikan nama kolom
    createdAt!: Date;

    @UpdateDateColumn({ name: 'updated_at' }) // Sesuaikan nama kolom
    updatedAt!: Date;

    role!: Role;

    isAccessTokenExpired(): boolean {
        return new Date() > this.accessTokenExpiredAt;
    }

    static newSessionTokenCacheKey(token: string): string {
        return `cache:id:session_token:${token}`;
    }

    static newSessionTokenCacheKeyByID(id: number): string {
        return `cache:object:session:id:${id}`;
    }
}
=====================


=====================
user.entity.ts
src/domain/entities/user.entity.ts
=====================
// src/domain/entities/user.entity.ts
import {
    Entity,
    PrimaryGeneratedColumn,
    Column,
    CreateDateColumn,
    UpdateDateColumn,
    BeforeInsert,
    BeforeUpdate
} from 'typeorm';
import { Role } from '@/utils/constants';
import bcrypt from "bcrypt";
import { Resource } from "@/domain/entities/resource.entity";
import { Action } from "@/domain/entities/action.entity";
import { RolePermission } from "@/rbac/role-permission";
import { Permission } from "@/rbac/permission";

@Entity('users')
export class User {
    constructor(data?: Partial<User>) {
        if (data) {
            Object.assign(this, data);
        }
    }

    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ unique: true })
    email!: string;

    @Column()
    password!: string;

    @Column({
        type: 'enum',
        enum: Role,
        default: Role.EMPLOYEE
    })
    role!: Role;

    @Column({ default: true, name: 'is_active' })
    isActive!: boolean; // Tambahkan nama kolom yang hilang

    @CreateDateColumn({ name: 'created_at' })
    createdAt!: Date;

    @UpdateDateColumn({ name: 'updated_at' })
    updatedAt!: Date;

    // Tambahkan property rolePerm
    private rolePerm: RolePermission | null = null;

    @BeforeInsert()
    @BeforeUpdate()
    async hashPassword() {
        if (this.password) {
            this.password = await bcrypt.hash(this.password, 10);
        }
    }

    hasAccess(resource: Resource, action: Action): boolean {
        if (this.rolePerm === null) {
            return false;
        }

        if (this.role === Role.INTERNAL_SERVICE) {
            this.role = Role.ADMIN;
        }

        return this.rolePerm.hasAccess(resource, action);
    }

    setPermission(perm: { RRA: Map<Role, Array<{ resource: string; action: string }>> } | null) {
        if (!perm) return;
        this.rolePerm = new RolePermission(this.role, new Permission(perm.RRA));
    }

    setRolePermission(rolePerm: RolePermission) {
        this.rolePerm = rolePerm;
    }

    getRolePermission(): { role: string; permissions: Array<{ resource: string; action: string }> } | null {
        if (!this.rolePerm) return null;

        // Ambil daftar permissions dari RolePermission
        const permissions = this.rolePerm.getPermissions();

        return {
            role: this.role, // Ambil role dari RolePermission
            permissions: permissions.map(perm => ({
                resource: perm.resource,
                action: perm.action
            }))
        };
    }


    isAdmin(): boolean {
        return this.role === Role.ADMIN;
    }
}
=====================


=====================
rbac.repository.ts
src/domain/repositories/rbac.repository.ts
=====================
import { Role } from '@/utils/constants';

export interface Permission {
    RRA: Map<Role, Array<{ resource: string; action: string }>>;
}

export interface RBACRepository {
    createResource(resource: string): Promise<void>;
    createAction(action: string): Promise<void>;
    createRoleResourceAction(role: Role, resource: string, action: string): Promise<void>;
    loadPermission(): Promise<Permission>;
    hasPermission(role: Role, resource: string, action: string): Promise<boolean>;
    initializeDefaultPermissions(): Promise<void>;
    findPermissionsByRole(role: Role): Promise<Array<{ resource: string; action: string }>>;
}
=====================


=====================
session.repository.ts
src/domain/repositories/session.repository.ts
=====================
import { Session } from '../entities/session.entity';
import { TokenType } from '@/utils/constants';

export interface SessionRepository {
    create(session: Session): Promise<Session>;
    findByToken(tokenType: TokenType, token: string): Promise<Session | null>;
    findById(id: number): Promise<Session | null>;
    findByUserId(userId: number): Promise<Session[]>;
    delete(id: number): Promise<void>;
    deleteByUserId(userId: number): Promise<void>;
    refreshToken(oldSession: Session, newSession: Session): Promise<void>;
}
=====================


=====================
user.repository.ts
src/domain/repositories/user.repository.ts
=====================
import { User } from '../entities/user.entity';
import {Role} from "@/utils/constants";

export interface UserRepository {
    create(user: User): Promise<User>;
    findById(id: number): Promise<User | null>;
    findUsersWithRole(role: Role): Promise<User[]>;
    findByEmail(email: string): Promise<User | null>;
    update(id: number, user: Partial<User>): Promise<User>;
    delete(id: number): Promise<void>;
}
=====================


=====================
auth.usecase.ts
src/domain/usecases/auth.usecase.ts
=====================
import { Role } from '@/utils/constants';
import {User} from "@/domain/entities/user.entity";

export interface LoginRequest {
    email: string;
    password: string;
    userAgent?: string;
    ipAddress?: string;
    latitude?: string;
    longitude?: string;
}

export interface LoginResponse {
    accessToken: string;
    refreshToken: string;
    user: {
        id: number;
        email: string;
        role: Role;
    };
    expiresIn: number;
}

export interface ValidateTokenResponse {
    userId: number;
    role: Role;
    permissions: Map<string, string[]>;
}

export interface AuthUseCase {
    login(req: LoginRequest): Promise<LoginResponse>;
    validateToken(token: string): Promise<User>;
    refreshToken(token: string): Promise<LoginResponse>;
    logout(token: string): Promise<void>;
}

export interface TokenData {
    userId: number;
    role: string;
    permissions: Map<string, string[]>;
}

export interface ValidateTokenResponse extends TokenData {}
=====================


=====================
index.ts
src/domain/usecases/index.ts
=====================
export * from './auth.usecase';
export * from './user.usecase';
=====================


=====================
user.usecase.ts
src/domain/usecases/user.usecase.ts
=====================
import { Role } from '@/utils/constants';
import {User} from "@/domain/entities/user.entity";

export interface UserUseCase {
    findById(userId: number): Promise<User>;
    createUser(data: { email: string; password: string; role: string }): Promise<User>;
}
=====================


=====================
index.ts
src/index.ts
=====================
// src/index.ts
import 'reflect-metadata';
import { Command } from 'commander';
import { Server } from './console/server';
import { migrateCommand } from './console/migrate';
import { createMigrationCommand } from './console/create-migration';
import { userSeederCommand } from './console/user.seeder';
import { migrateRBACCommand } from './console/migrate-rbac';

const program = new Command();

program
    .name('auth-service')
    .description('Authentication Service CLI')
    .version('1.0.0');

// Add commands
program.addCommand(migrateCommand);
program.addCommand(createMigrationCommand);
program.addCommand(migrateRBACCommand);
program.addCommand(userSeederCommand);

// Add server command
program
    .command('serve')
    .description('Start the server')
    .action(async () => {
        const server = new Server();
        await server.start();
    });

program.parse();
=====================


=====================
auth_grpc_pb.d.ts
src/proto/auth_grpc_pb.d.ts
=====================

"auth_grpc_pb.d.ts" is not a text file (MIME type: cannot open `src/proto/auth_grpc_pb.d.ts' (No such file or directory))

=====================


=====================
auth_grpc_pb.js
src/proto/auth_grpc_pb.js
=====================

"auth_grpc_pb.js" is not a text file (MIME type: cannot open `src/proto/auth_grpc_pb.js' (No such file or directory))

=====================


=====================
auth_pb.d.ts
src/proto/auth_pb.d.ts
=====================

"auth_pb.d.ts" is not a text file (MIME type: cannot open `src/proto/auth_pb.d.ts' (No such file or directory))

=====================


=====================
auth_pb.js
src/proto/auth_pb.js
=====================

"auth_pb.js" is not a text file (MIME type: cannot open `src/proto/auth_pb.js' (No such file or directory))

=====================


=====================
permission.ts
src/rbac/permission.ts
=====================
// src/rbac/permission.ts
import { Resource } from "@/domain/entities/resource.entity";
import { Action } from "@/domain/entities/action.entity";
import { Role } from "@/utils/constants";
import { Context } from "@/utils/context";

export class Permission {
    constructor(
        private resourceActions: Map<Role, Array<{ resource: string; action: string }>>
    ) {}

    hasAccess(resource: Resource, action: Action): boolean {
        const role = Context.getUser()?.role;
        if (!role) return false;

        const rolePermissions = this.resourceActions.get(role);
        if (!rolePermissions) return false;

        return rolePermissions.some(
            (perm) => perm.resource === resource.id && perm.action === action.id
        );
    }

    getPermissionsForRole(role: Role): Array<{ resource: string; action: string }> {
        return this.resourceActions.get(role) || [];
    }
}
=====================


=====================
role-permission.ts
src/rbac/role-permission.ts
=====================
// src/rbac/role-permission.ts
import { Role } from "@/utils/constants";
import { Permission } from "@/rbac/permission";
import { Resource } from "@/domain/entities/resource.entity";
import { Action } from "@/domain/entities/action.entity";

export class RolePermission {
    constructor(
        private role: Role,
        private permission: Permission
    ) {}

    hasAccess(resource: Resource, action: Action): boolean {
        // Admin has all permissions
        if (this.role === Role.ADMIN) {
            return true;
        }

        return this.permission.hasAccess(resource, action);
    }

    getPermissions(): Array<{ resource: string; action: string }> {
        return this.permission.getPermissionsForRole(this.role);
    }
}
=====================


=====================
rbac.repository.ts
src/repository/rbac.repository.ts
=====================
// src/repository/rbac.repository.ts
import { injectable, inject } from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { DEFAULT_ACTIONS, DEFAULT_RESOURCES, Role } from '@/utils/constants';
import { Resource } from '@/domain/entities/resource.entity';
import { Action } from '@/domain/entities/action.entity';
import { RoleResourceAction } from '@/domain/entities/roleResourceAction.entity';
import { RBACRepository, Permission } from '@/domain/repositories/rbac.repository';

@injectable()
export class RBACRepositoryImpl implements RBACRepository {
    private resourceRepo: Repository<Resource>;
    private actionRepo: Repository<Action>;
    private rraRepo: Repository<RoleResourceAction>;
    private RBAC_PERMISSION_CACHE_KEY = 'cache:object:rbac:permission';

    constructor(
        @inject('DataSource') private dataSource: DataSource, // Inject DataSource
        @inject('Redis') private redis: Redis // Inject Redis
    ) {
        if (!dataSource.isInitialized) {
            throw new Error('DataSource is not initialized');
        }

        this.resourceRepo = dataSource.getRepository(Resource);
        this.actionRepo = dataSource.getRepository(Action);
        this.rraRepo = dataSource.getRepository(RoleResourceAction);
    }

    async createResource(resource: string): Promise<void> {
        const res = new Resource();
        res.id = resource;
        await this.resourceRepo.save(res);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createAction(action: string): Promise<void> {
        const act = new Action();
        act.id = action;
        await this.actionRepo.save(act);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createRoleResourceAction(role: Role, resource: string, action: string): Promise<void> {
        const rra = new RoleResourceAction();
        rra.role = role;
        rra.resource = resource;
        rra.action = action;
        await this.rraRepo.save(rra);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async loadPermission(): Promise<Permission> {
        const cachedPermission = await this.redis.get(this.RBAC_PERMISSION_CACHE_KEY);
        if (cachedPermission) {
            const parsed = JSON.parse(cachedPermission);
            // Konversi object ke Map dengan tipe yang benar
            const rraMap = new Map<Role, Array<{ resource: string; action: string }>>();

            // Iterasi setiap entry dan konversi ke format yang benar
            Object.entries(parsed.RRA).forEach(([role, permissions]) => {
                rraMap.set(role as Role, permissions as Array<{ resource: string; action: string }>);
            });

            return { RRA: rraMap };
        }

        const permissions = await this.rraRepo.find();
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();

        permissions.forEach(permission => {
            const rolePermissions = permissionMap.get(permission.role) || [];
            rolePermissions.push({
                resource: permission.resource,
                action: permission.action
            });
            permissionMap.set(permission.role, rolePermissions);
        });

        // Konversi Map ke Object sebelum cache
        const permissionObject = {
            RRA: Object.fromEntries(permissionMap)
        };

        await this.redis.set(
            this.RBAC_PERMISSION_CACHE_KEY,
            JSON.stringify(permissionObject),
            'EX',
            3600
        );

        return { RRA: permissionMap };
    }

    async hasPermission(role: Role, resource: string, action: string): Promise<boolean> {
        const permission = await this.loadPermission();
        const rolePermissions = permission.RRA.get(role) || [];

        return rolePermissions.some(
            rra => rra.resource === resource && rra.action === action
        );
    }

    async initializeDefaultPermissions(): Promise<void> {
        // Create default resources
        for (const resource of Object.values(DEFAULT_RESOURCES)) {
            await this.createResource(resource);
        }

        // Create default actions
        for (const action of Object.values(DEFAULT_ACTIONS)) {
            await this.createAction(action);
        }

        // Create default role-resource-actions
        const defaultPermissions = [
            // Admin permissions
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.CREATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.READ },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.UPDATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.DELETE },

            // Manager permissions
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.EMPLOYEE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.APPROVE },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.REJECT },

            // Employee permissions
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.SUBMIT },
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
        ];

        for (const perm of defaultPermissions) {
            await this.createRoleResourceAction(perm.role, perm.resource, perm.action);
        }
    }

    async findPermissionsByRole(role: Role): Promise<Array<{ resource: string; action: string }>> {
        // Cek cache terlebih dahulu
        const cachedPermission = await this.redis.get(this.RBAC_PERMISSION_CACHE_KEY);
        if (cachedPermission) {
            const parsed = JSON.parse(cachedPermission);
            const rraMap = new Map<Role, Array<{ resource: string; action: string }>>();

            // Konversi cached data
            Object.entries(parsed.RRA).forEach(([cachedRole, permissions]) => {
                rraMap.set(cachedRole as Role, permissions as Array<{ resource: string; action: string }>);
            });

            // Ambil permissions untuk role yang diminta
            const rolePermissions = rraMap.get(role);
            if (rolePermissions) {
                return rolePermissions;
            }
        }

        // Jika tidak ada di cache, ambil dari database
        const permissions = await this.rraRepo.find({
            where: { role }
        });

        const result = permissions.map(p => ({
            resource: p.resource,
            action: p.action
        }));

        // Update cache dengan data baru
        const allPermissions = await this.rraRepo.find();
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();

        allPermissions.forEach(permission => {
            const rolePermissions = permissionMap.get(permission.role) || [];
            rolePermissions.push({
                resource: permission.resource,
                action: permission.action
            });
            permissionMap.set(permission.role, rolePermissions);
        });

        // Simpan ke cache
        const permissionObject = {
            RRA: Object.fromEntries(permissionMap)
        };

        await this.redis.set(
            this.RBAC_PERMISSION_CACHE_KEY,
            JSON.stringify(permissionObject),
            'EX',
            3600
        );

        return result;
    }
}
=====================


=====================
session.repository.ts
src/repository/session.repository.ts
=====================
// src/repository/session.repository.ts
import {inject, injectable} from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { Session } from '@/domain/entities/session.entity';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { TokenType } from '@/utils/constants';

@injectable()
export class SessionRepositoryImpl implements SessionRepository {
    private repository: Repository<Session>;

    constructor(
        @inject('DataSource') private dataSource: DataSource,
        @inject('Redis') private redis: Redis
    ) {
        if (!dataSource.isInitialized) {
            throw new Error('DataSource is not initialized');
        }
        this.repository = dataSource.getRepository(Session);
    }

    async create(session: Session): Promise<Session> {
        const savedSession = await this.repository.save(session);
        await this.cacheSession(savedSession);
        return savedSession;
    }

    async findByToken(tokenType: TokenType, token: string): Promise<Session | null> {
        console.log(`SessionRepositoryImpl.findByToken called with type: ${tokenType}, token: ${token}`);

        const cacheKey = Session.newSessionTokenCacheKey(token);

        // Try to get from cache first
        const cachedSession = await this.redis.get(cacheKey);
        if (cachedSession) {
            const sessionData = JSON.parse(cachedSession);
            return this.transformToSessionEntity(sessionData);
        }

        const session = await this.repository.findOne({
            where: tokenType === TokenType.ACCESS_TOKEN
                ? { accessToken: token }
                : { refreshToken: token }
        });

        if (session) {
            // Cache the session
            await this.cacheSession(session);
            return this.transformToSessionEntity(session);
        }

        return session;
    }

    private transformToSessionEntity(data: any): Session {
        const session = new Session();
        Object.assign(session, {
            id: data.id,
            userId: data.userId,
            accessToken: data.accessToken,
            refreshToken: data.refreshToken,
            accessTokenExpiredAt: new Date(data.accessTokenExpiredAt),
            refreshTokenExpiredAt: new Date(data.refreshTokenExpiredAt),
            userAgent: data.userAgent,
            latitude: data.latitude,
            longitude: data.longitude,
            ipAddress: data.ipAddress,
            createdAt: new Date(data.createdAt),
            updatedAt: new Date(data.updatedAt),
            role: data.role
        });
        return session;
    }

    private async cacheSession(session: Session): Promise<void> {
        const cacheKey = Session.newSessionTokenCacheKey(session.accessToken);
        await this.redis.set(cacheKey, JSON.stringify(session), 'EX', 3600); // 1 hour
    }

    async delete(id: number): Promise<void> {
        await this.repository.delete(id);
        const cacheKey = Session.newSessionTokenCacheKeyByID(id);
        await this.redis.del(cacheKey);
    }

    async deleteByUserId(userId: number): Promise<void> {
        const sessions = await this.repository.find({ where: { userId } });
        for (const session of sessions) {
            await this.delete(session.id);
        }
    }

    async findById(id: number): Promise<Session | null> {
        const cacheKey = Session.newSessionTokenCacheKeyByID(id);
        const cachedSession = await this.redis.get(cacheKey);

        if (cachedSession) {
            return JSON.parse(cachedSession);
        }

        const session = await this.repository.findOne({
            where: { id: id }
        });

        if (session) {
            await this.cacheSession(session);
        }

        return session;
    }

    async findByUserId(userId: number): Promise<Session[]> {
        return await this.repository.find({ where: { userId } });
    }

    // Implementasi refreshToken
    async refreshToken(oldSession: Session, newSession: Session): Promise<void> {
        // Hapus sesi lama
        await this.delete(oldSession.id);

        // Simpan sesi baru
        await this.create(newSession);
    }
}
=====================


=====================
user.repository.ts
src/repository/user.repository.ts
=====================
import {inject, injectable} from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { User } from '@/domain/entities/user.entity';
import { UserRepository } from '@/domain/repositories/user.repository';
import {Role} from "@/utils/constants";
import { Redis } from "ioredis";

@injectable()
export class UserRepositoryImpl implements UserRepository {
    private repository: Repository<User>;

    constructor(
        @inject('DataSource') private dataSource: DataSource,
        @inject('Redis') private redis: Redis
    ) {
        this.repository = dataSource.getRepository(User);
    }

    // Create a new user and invalidate cache
    async create(user: User): Promise<User> {
        const savedUser = await this.repository.save(user);

        // Invalidate cache
        await this.invalidateCacheById(savedUser.id);
        await this.invalidateCacheByEmail(savedUser.email);

        return savedUser;
    }

    // Find user by ID with caching
    async findById(id: number): Promise<User | null> {
        const cacheKey = this.getCacheKeyById(id);

        // Check Redis cache
        const cachedUser = await this.redis.get(cacheKey);
        if (cachedUser) {
            return JSON.parse(cachedUser) as User;
        }

        // Fetch from database if not in cache
        const user = await this.repository.findOneBy({ id });
        if (user) {
            await this.cacheUser(user);
        }

        return user;
    }

    async findUsersWithRole(role: Role): Promise<User[]> {
        return this.repository
            .createQueryBuilder('user')
            .where('user.role = :role', { role })
            .getMany();
    }

    // Find user by email with caching
    async findByEmail(email: string): Promise<User | null> {
        const cacheKey = this.getCacheKeyByEmail(email);

        // Check Redis cache for ID
        const cachedId = await this.redis.get(cacheKey);
        if (cachedId) {
            return this.findById(Number(cachedId));
        }

        // Fetch user from database if not in cache
        const user = await this.repository.findOneBy({ email });
        if (user) {
            // Cache the ID and user data
            await this.cacheUser(user);
        }

        return user;
    }

    // Update user and invalidate cache
    async update(id: number, userData: Partial<User>): Promise<User> {
        await this.repository.update(id, userData);

        // Invalidate cache
        await this.invalidateCacheById(id);

        // Fetch updated user
        const updatedUser = await this.findById(id);
        return updatedUser!;
    }

    // Delete user and invalidate cache
    async delete(id: number): Promise<void> {
        const user = await this.findById(id);
        if (user) {
            // Invalidate cache
            await this.invalidateCacheById(id);
            await this.invalidateCacheByEmail(user.email);
        }

        await this.repository.delete(id);
    }

    // Cache user data in Redis
    private async cacheUser(user: User): Promise<void> {
        const cacheKeyById = this.getCacheKeyById(user.id);
        const cacheKeyByEmail = this.getCacheKeyByEmail(user.email);

        // Cache user data with a TTL of 1 hour
        const userData = JSON.stringify(user);
        await this.redis.set(cacheKeyById, userData, 'EX', 3600);
        await this.redis.set(cacheKeyByEmail, user.id.toString(), 'EX', 3600);
    }

    // Invalidate cache by user ID
    private async invalidateCacheById(id: number): Promise<void> {
        const cacheKey = this.getCacheKeyById(id);
        await this.redis.del(cacheKey);
    }

    // Invalidate cache by user email
    private async invalidateCacheByEmail(email: string): Promise<void> {
        const cacheKey = this.getCacheKeyByEmail(email);
        await this.redis.del(cacheKey);
    }

    // Generate cache key for user by ID
    private getCacheKeyById(id: number): string {
        return `cache:user:id:${id}`;
    }

    // Generate cache key for user by email
    private getCacheKeyByEmail(email: string): string {
        return `cache:user:email:${email}`;
    }
}
=====================


=====================
index.d.ts
src/types/express/index.d.ts
=====================
// src/types/express/index.d.ts
import { User } from '@/domain/entities/user.entity';

declare global {
    namespace Express {
        interface Request {
            user?: {
                userId: number;
                role: string;
                permissions: Map<string, string[]>;
            };
        }
    }
}
=====================


=====================
auth.usecase.ts
src/usecase/auth.usecase.ts
=====================
import {AuthUseCase, LoginRequest, LoginResponse, ValidateTokenResponse} from "@/domain/usecases/auth.usecase";
import {inject, injectable} from "tsyringe";
import {UserRepository} from "@/domain/repositories/user.repository";
import {SessionRepository} from "@/domain/repositories/session.repository";
import {RBACRepository} from "@/domain/repositories/rbac.repository";
import {AuthError} from "@/utils/errors";
import bcrypt from "bcrypt";
import {randomBytes} from "crypto";
import {Session} from "@/domain/entities/session.entity";
import {Role, TokenType} from "@/utils/constants";
import {User} from "@/domain/entities/user.entity";

@injectable()
export class AuthUseCaseImpl implements AuthUseCase {
    constructor(
        @inject('UserRepository') private userRepo: UserRepository,
        @inject('SessionRepository') private sessionRepo: SessionRepository,
        @inject('RBACRepository') private rbacRepo: RBACRepository
    ) {}

    async login(req: LoginRequest): Promise<LoginResponse> {
        // Find user
        const user = await this.userRepo.findByEmail(req.email);
        if (!user) {
            throw new AuthError('Invalid email or password');
        }

        // Validate password
        const isValidPassword = await bcrypt.compare(req.password, user.password).catch(() => false);
        if (!isValidPassword) {
            throw new AuthError('Invalid email or password');
        }

        // Validate latitude and longitude
        const latitude = req.latitude || '0';
        const longitude = req.longitude || '0';
        if (isNaN(parseFloat(latitude)) || isNaN(parseFloat(longitude))) {
            throw new AuthError('Invalid location data');
        }

        // Generate tokens
        const accessToken = randomBytes(32).toString('hex');
        const refreshToken = randomBytes(32).toString('hex');

        // Create session
        const now = new Date();
        const session = new Session();
        session.userId = user.id;
        session.accessToken = accessToken;
        session.refreshToken = refreshToken;
        session.accessTokenExpiredAt = new Date(now.getTime() + 1 * 60 * 60 * 1000); // 1 hour
        session.refreshTokenExpiredAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
        session.userAgent = req.userAgent || '';
        session.ipAddress = req.ipAddress || '';
        session.latitude = latitude;
        session.longitude = longitude;
        session.createdAt = now;
        session.updatedAt = now;

        await this.sessionRepo.create(session);

        // Load permissions
        const permissions = await this.rbacRepo.loadPermission();

        return {
            accessToken,
            refreshToken,
            user: {
                id: user.id,
                email: user.email,
                role: user.role,
            },
            expiresIn: session.accessTokenExpiredAt.getTime(),
        };
    }

    async logout(token: string): Promise<void> {
        const session = await this.sessionRepo.findByToken(TokenType.ACCESS_TOKEN, token);
        if (!session) {
            throw new AuthError('Invalid token');
        }

        await this.sessionRepo.delete(session.id);
    }

    async refreshToken(refreshToken: string): Promise<LoginResponse> {
        // Find session by refresh token
        const oldSession = await this.sessionRepo.findByToken(TokenType.REFRESH_TOKEN, refreshToken);
        if (!oldSession) {
            throw new AuthError('Invalid refresh token');
        }

        // Generate new tokens
        const accessToken = randomBytes(32).toString('hex');
        const newRefreshToken = randomBytes(32).toString('hex');

        // Create new session
        const now = new Date();
        const newSession = new Session();
        newSession.userId = oldSession.userId;
        newSession.accessToken = accessToken;
        newSession.refreshToken = newRefreshToken;
        newSession.accessTokenExpiredAt = new Date(now.getTime() + 1 * 60 * 60 * 1000);
        newSession.refreshTokenExpiredAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        newSession.userAgent = oldSession.userAgent;
        newSession.ipAddress = oldSession.ipAddress;
        newSession.latitude = oldSession.latitude;
        newSession.longitude = oldSession.longitude;
        newSession.createdAt = now;
        newSession.updatedAt = now;

        // Refresh session
        await this.sessionRepo.refreshToken(oldSession, newSession);

        // Get user data
        const user = await this.userRepo.findById(oldSession.userId);
        if (!user) {
            throw new AuthError('User not found');
        }

        return {
            accessToken,
            refreshToken: newRefreshToken,
            user: {
                id: user.id,
                email: user.email,
                role: user.role
            },
            expiresIn: newSession.accessTokenExpiredAt.getTime()
        };
    }

    async validateToken(token: string): Promise<User> {
        console.log('Executing ValidateTokenUseCase with token:', token);
        const session = await this.sessionRepo.findByToken(TokenType.ACCESS_TOKEN, token);
        if (!session) {
            throw new AuthError('Invalid token');
        }

        // Check if token is expired
        if (session.isAccessTokenExpired()) {
            throw new AuthError('Token expired');
        }

        const existUser = await this.userRepo.findById(session.userId);
        if (!existUser) {
            throw new AuthError('Invalid user');
        }

        // Load user permissions
        const permissions = await this.rbacRepo.findPermissionsByRole(existUser.role);

        // Transform permissions ke Map<Role, Array<{ resource: string; action: string }>>
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();
        permissions.forEach(({ resource, action }) => {
            const rolePermissions = permissionMap.get(existUser.role) || [];
            rolePermissions.push({ resource, action });
            permissionMap.set(existUser.role, rolePermissions);
        });

        const user = new User(existUser);
        user.id = session.userId;
        user.role = existUser.role;
        user.setPermission({ RRA: permissionMap });

        return user;
    }

}
=====================


=====================
user.usecase.ts
src/usecase/user.usecase.ts
=====================
// src/usecase/user.usecase.ts
import { inject, injectable } from 'tsyringe';
import { UserRepository } from '@/domain/repositories/user.repository';
import { checkAccess } from '@/utils/rbac';
import {EnumHelper} from "@/utils/enum-helper";
import {User} from "@/domain/entities/user.entity";
import {UserUseCase} from "@/domain/usecases/user.usecase";
import {AppError} from "@/utils/errors";
import {Resource} from "@/domain/entities/resource.entity";
import {DEFAULT_ACTIONS, DEFAULT_RESOURCES} from "@/utils/constants";

@injectable()
export class UserUsecaseImpl implements UserUseCase {
    constructor(
        @inject('UserRepository') private userRepo: UserRepository
    ) {}

    async findById(userId: number): Promise<User> {
        checkAccess(DEFAULT_RESOURCES.USER, DEFAULT_ACTIONS.READ);

        // Fetch user dari repository
        const user = await this.userRepo.findById(userId);
        if (!user) {
            throw new AppError('User not found', 404);
        }

        return user;
    }

    async createUser(data: { email: string; password: string; role: string }): Promise<User> {
        // Periksa akses ke resource "user" dengan action "read"
        checkAccess('user', 'create');

        // Buat instance baru dari User
        const newUser = new User();
        newUser.email = data.email;
        newUser.password = data.password;
        newUser.role = EnumHelper.toRole(data.role);
        newUser.isActive = true;
        newUser.createdAt = new Date();
        newUser.updatedAt = new Date();

        // Buat user baru
        const user = await this.userRepo.create(newUser);

        return user;
    }
}
=====================


=====================
SqlMigrationLoader.ts
src/utils/SqlMigrationLoader.ts
=====================

"SqlMigrationLoader.ts" is not a text file (MIME type: cannot open `src/utils/SqlMigrationLoader.ts' (No such file or directory))

=====================


=====================
constants.ts
src/utils/constants.ts
=====================
// src/utils/constants.ts
export enum Role {
    ADMIN = 'ADMIN',
    MANAGER = 'MANAGER',
    EMPLOYEE = 'EMPLOYEE',
    INTERNAL_SERVICE = 'INTERNAL_SERVICE'
}

export const DEFAULT_RESOURCES = {
    USER: 'user',
    EMPLOYEE: 'employee',
    ATTENDANCE: 'attendance',
    SESSION: 'session',
    REPORT: 'report'
} as const;

export const DEFAULT_ACTIONS = {
    CREATE: 'create',
    READ: 'read',
    UPDATE: 'update',
    DELETE: 'delete',
    APPROVE: 'approve',
    REJECT: 'reject',
    SUBMIT: 'submit'
} as const;

export enum TokenType {
    ACCESS_TOKEN = 0,
    REFRESH_TOKEN = 1
}
=====================


=====================
context.ts
src/utils/context.ts
=====================
// src/utils/context.ts
import { AsyncLocalStorage } from 'node:async_hooks';
import { User } from '@/domain/entities/user.entity';

interface RequestContext {
    user: User | null;
}

const asyncLocalStorage = new AsyncLocalStorage<RequestContext>();

export const Context = {
    run: (context: RequestContext, callback: () => void) => {
        asyncLocalStorage.run(context, callback);
    },
    get: (): RequestContext | undefined => {
        return asyncLocalStorage.getStore();
    },
    setUser: (user: User | null) => {
        const store = asyncLocalStorage.getStore();
        if (store) {
            store.user = user;
        }
    },
    getUser: (): User | null => {
        const store = asyncLocalStorage.getStore();
        return store?.user || null;
    },
};
=====================


=====================
enum-helper.ts
src/utils/enum-helper.ts
=====================
// src/utils/enum-helper.ts
import { Role } from '@/utils/constants';

export class EnumHelper {
    static isValidRole(role: string): role is Role {
        return Object.values(Role).includes(role as Role);
    }

    static toRole(role: string): Role {
        if (!this.isValidRole(role)) {
            throw new Error(`Invalid role: ${role}`);
        }
        return role as Role;
    }
}
=====================


=====================
AppError.ts
src/utils/errors/AppError.ts
=====================
export class AppError extends Error {
    public readonly statusCode: number;

    constructor(message: string, statusCode: number) {
        super(message);
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, AppError.prototype);
    }
}
=====================


=====================
AuthError.ts
src/utils/errors/AuthError.ts
=====================
export class AuthError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'AuthError';
    }
}
=====================


=====================
PermissionError.ts
src/utils/errors/PermissionError.ts
=====================
export class PermissionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'PermissionError';
    }
}
=====================


=====================
index.ts
src/utils/errors/index.ts
=====================
export * from './AppError';
export * from './AuthError';
export * from './PermissionError';
=====================


=====================
hashHelper.ts
src/utils/helpers/hashHelper.ts
=====================
import bcrypt from 'bcrypt';

export const hashString = async (input: string): Promise<string> => {
    return await bcrypt.hash(input, 10);
};
=====================


=====================
index.ts
src/utils/helpers/index.ts
=====================
export * from './phoneNumberHelper';
export * from './hashHelper';
=====================


=====================
phoneNumberHelper.ts
src/utils/helpers/phoneNumberHelper.ts
=====================
export const formatPhoneNumber = (phoneNumber: string): string => {
    // Implementasi format nomor telepon
    return phoneNumber; // Ganti dengan logika format yang sesuai
};
=====================


=====================
logger.ts
src/utils/logger.ts
=====================
export const Logger = {
    info: (message: string, ...args: any[]) => {
        console.log(`[INFO] ${message}`, ...args);
    },
    error: (message: string, ...args: any[]) => {
        console.error(`[ERROR] ${message}`, ...args);
    },
    warn: (message: string, ...args: any[]) => {
        console.warn(`[WARN] ${message}`, ...args);
    }
};
=====================


=====================
rbac.ts
src/utils/rbac.ts
=====================
// src/utils/rbac.ts
import { Context } from '@/utils/context';
import { AppError } from "@/utils/errors";
import { Role } from "@/utils/constants";
import { Resource } from "@/domain/entities/resource.entity";
import { Action } from "@/domain/entities/action.entity";

export const checkAccess = (resource: string, action: string): void => {
    const user = Context.getUser();
    console.log('Current User:', user); // Debugging

    if (!user) {
        console.error('Unauthorized access attempt'); // Debugging
        throw new AppError('Unauthorized', 401);
    }

    // Jika user adalah internal service, bypass permission check
    if (user.role === Role.INTERNAL_SERVICE) {
        console.log('Internal service call'); // Debugging
        return;
    }

    // Buat instance Resource dan Action untuk pengecekan
    const resourceEntity = new Resource();
    resourceEntity.id = resource;

    const actionEntity = new Action();
    actionEntity.id = action;

    // Gunakan method hasAccess dari User entity
    if (!user.hasAccess(resourceEntity, actionEntity)) {
        console.error(`Permission denied for resource: ${resource}, action: ${action}`); // Debugging
        throw new AppError('Permission denied', 403);
    }
};
=====================


=====================
token.ts
src/utils/token.ts
=====================
// src/utils/token.ts
import { randomBytes } from 'crypto';

export function generateToken(length: number = 32): string {
    return randomBytes(length).toString('hex');
}
=====================


=====================
tsconfig.json
tsconfig.json
=====================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "ES2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    "lib": ["es2020"],                                   /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
     "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
     "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./src",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    "baseUrl": ".",                                  /* Specify the base directory to resolve non-relative module names. */
    "paths": {
      "@/*": ["./src/*"]
    },
    "typeRoots": [
      "./node_modules/@types",
      "./src/types"
    ],
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
     "outDir": "./dist",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

=====================


