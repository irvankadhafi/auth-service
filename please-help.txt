
=====================
1678901234567-create-users.sql
db/migration/1678901234567-create-users.sql
=====================
-- +migrate Up
CREATE TABLE IF NOT EXISTS "users" (
    "id" SERIAL PRIMARY KEY,
    "email" VARCHAR(255) UNIQUE NOT NULL,
    "password" VARCHAR(255) NOT NULL,
    "role" VARCHAR(50) NOT NULL,
    "is_active" BOOLEAN DEFAULT true,
    "created_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- +migrate Down
DROP TABLE IF EXISTS "users";
=====================


=====================
1678901234568-create-sessions.sql
db/migration/1678901234568-create-sessions.sql
=====================
-- +migrate Up
CREATE TABLE IF NOT EXISTS "sessions" (
    "id" SERIAL PRIMARY KEY,
    "user_id" INTEGER NOT NULL,
    "access_token" VARCHAR(255) UNIQUE NOT NULL,
    "refresh_token" VARCHAR(255) UNIQUE NOT NULL,
    "access_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
    "refresh_token_expired_at" TIMESTAMP WITH TIME ZONE NOT NULL,
    "user_agent" VARCHAR(255),
    "latitude" VARCHAR(50),
    "longitude" VARCHAR(50),
    "ip_address" VARCHAR(50),
    "created_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY ("user_id") REFERENCES "users" ("id")
);

-- +migrate Down
DROP TABLE IF EXISTS "sessions";
=====================


=====================
1678901234569-create-role-resource-actions.sql
db/migration/1678901234569-create-role-resource-actions.sql
=====================
-- +migrate Up
CREATE TYPE user_role AS ENUM ('ADMIN', 'MANAGER', 'EMPLOYEE');
CREATE TYPE resource_type AS ENUM ('user', 'employee', 'attendance', 'session', 'report');
CREATE TYPE action_type AS ENUM ('create', 'read', 'update', 'delete', 'approve', 'reject', 'submit');

CREATE TABLE IF NOT EXISTS "resources" (
    "id" resource_type PRIMARY KEY
);

CREATE TABLE IF NOT EXISTS "actions" (
    "id" action_type PRIMARY KEY
);

CREATE TABLE IF NOT EXISTS "role_resource_actions" (
    "role" user_role NOT NULL,
    "resource" resource_type NOT NULL REFERENCES "resources"("id"),
    "action" action_type NOT NULL REFERENCES "actions"("id"),
    PRIMARY KEY ("role", "resource", "action")
);

-- +migrate Down
DROP TABLE IF EXISTS "role_resource_actions";
DROP TABLE IF EXISTS "actions";
DROP TABLE IF EXISTS "resources";
DROP TYPE IF EXISTS action_type;
DROP TYPE IF EXISTS resource_type;
DROP TYPE IF EXISTS user_role;
=====================


=====================
package.json
package.json
=====================

{
  "name": "auth-service",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "_moduleAliases": {
    "@": "dist"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/node": "^22.10.5",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "@apollo/server": "^4.11.3",
    "@apollo/subgraph": "^2.9.3",
    "@grpc/grpc-js": "^1.12.5",
    "@grpc/proto-loader": "^0.7.13",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "commander": "^13.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "graphql": "^16.10.0",
    "ioredis": "^5.4.2",
    "module-alias": "^2.2.3",
    "pg": "^8.13.1",
    "redis": "^4.7.0",
    "reflect-metadata": "^0.2.2",
    "tsyringe": "^4.8.0",
    "typeorm": "^0.3.20"
  }
}

=====================


=====================
container.ts
src/config/container.ts
=====================
// src/config/container.ts
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { UserRepository } from '@/domain/repositories/user.repository';
import { UserRepositoryImpl } from '@/repository/user.repository';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { SessionRepositoryImpl } from '@/repository/session.repository';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { RBACRepositoryImpl } from '@/repository/rbac.repository';
import { LoginUseCase } from '@/usecase/auth/login.usecase';
import { ValidateTokenUseCase } from '@/usecase/auth/validate-token.usecase';

export function setupContainer() {
    // Database
    const dataSource = new DataSource({
        // database configuration
    });

    // Redis
    const redis = new Redis({
        // redis configuration
    });

    // Repositories
    container.registerInstance('DataSource', dataSource);
    container.registerInstance('Redis', redis);
    container.registerSingleton<UserRepository>('UserRepository', UserRepositoryImpl);
    container.registerSingleton<SessionRepository>('SessionRepository', SessionRepositoryImpl);
    container.registerSingleton<RBACRepository>('RBACRepository', RBACRepositoryImpl);

    // Use Cases
    container.registerSingleton(LoginUseCase);
    container.registerSingleton(ValidateTokenUseCase);
}
=====================


=====================
database.ts
src/config/database.ts
=====================
import { DataSource } from 'typeorm';
import { config } from 'dotenv';

config();

export const AppDataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432'),
    username: process.env.DB_USERNAME,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    synchronize: true,
    logging: true,
    entities: ['src/domain/entities/**/*.ts'],
    // migrations: ['src/infrastructure/database/migrations/**/*.ts'],
    migrations: ['db/migration/*.sql'], // Path ke file migrasi
    migrationsTableName: 'schema_migrations', // Nama tabel untuk menyimpan status migrasi
});
=====================


=====================
index.ts
src/config/index.ts
=====================
import dotenv from 'dotenv';

dotenv.config();

export class Config {
    static get NODE_ENV(): string {
        return process.env.NODE_ENV || 'development';
    }

    static get DATABASE_URL(): string {
        return process.env.DATABASE_URL || 'postgresql://localhost:5432/auth_db';
    }

    static get REDIS_URL(): string {
        return process.env.REDIS_URL || 'redis://localhost:6379';
    }

    static get HTTP_PORT(): number {
        return parseInt(process.env.HTTP_PORT || '3000');
    }

    static get GRPC_PORT(): number {
        return parseInt(process.env.GRPC_PORT || '50051');
    }

    static get JWT_SECRET(): string {
        return process.env.JWT_SECRET || 'your-secret-key';
    }
}
=====================


=====================
redis.ts
src/config/redis.ts
=====================
import Redis from 'ioredis';
import { config } from 'dotenv';

config();

export const redis = new Redis({
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || '6379'),
});
=====================


=====================
migrate.ts
src/console/migrate.ts
=====================
// src/console/migrate.ts
import { Command } from 'commander';
import { DataSource } from 'typeorm';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';

export const migrateCommand = new Command('migrate')
    .description('Database migration command')
    .option('--step <number>', 'maximum migration steps', '0')
    .option('--direction <string>', 'migration direction (up/down)', 'up')
    .action(async (options) => {
        try {
            const direction = options.direction;
            const step = parseInt(options.step);

            const dataSource = new DataSource({
                type: 'postgres',
                url: Config.DATABASE_URL,
                entities: ['src/domain/entities/*.entity.ts'],
                migrations: ['db/migration/*.ts'],
                migrationsTableName: 'schema_migrations'
            });

            await dataSource.initialize();

            if (direction === 'down') {
                await dataSource.undoLastMigration();
            } else {
                await dataSource.runMigrations();
            }

            Logger.info(`Applied migrations successfully!`);
            process.exit(0);
        } catch (error) {
            Logger.error('Migration failed:', error);
            process.exit(1);
        }
    });
=====================


=====================
server.ts
src/console/server.ts
=====================
// src/console/server.ts
import express from 'express';
import { createServer } from 'http';
import { container } from 'tsyringe';
import { DataSource } from 'typeorm';
import Redis from 'ioredis';
import { Logger } from '@/utils/logger';
import { Config } from '@/config';
import { setupRoutes } from '@/delivery/http/routes';
// import { setupGraphQL } from '@/delivery/graphql';
// import { setupGRPC } from '@/delivery/grpc';

// Repositories
import { UserRepositoryImpl } from '@/repository/user.repository';
import { SessionRepositoryImpl } from '@/repository/session.repository';
import { RBACRepositoryImpl } from '@/repository/rbac.repository';

// Use Cases
import { LoginUseCase } from '@/usecase/auth/login.usecase';
import { ValidateTokenUseCase } from '@/usecase/auth/validate-token.usecase';

export class Server {
    private httpServer: express.Application;
    private dataSource: DataSource;
    private redis: Redis;
    private logger: typeof Logger;

    constructor() {
        this.httpServer = express();
        this.logger = Logger;
    }

    async initialize(): Promise<void> {
        await this.setupDatabase();
        await this.setupRedis();
        await this.setupDependencyInjection();
    }

    private async setupDatabase(): Promise<void> {
        this.dataSource = new DataSource({
            type: 'postgres',
            url: Config.DATABASE_URL,
            entities: ['src/domain/entities/*.entity.ts'],
            synchronize: false,
            logging: true
        });

        await this.dataSource.initialize();
        this.logger.info('Database connected successfully');
    }

    private async setupRedis(): Promise<void> {
        this.redis = new Redis(Config.REDIS_URL);
        this.logger.info('Redis connected successfully');
    }

    private async setupDependencyInjection(): Promise<void> {
        // Register instances
        container.registerInstance('DataSource', this.dataSource);
        container.registerInstance('Redis', this.redis);
        container.registerInstance('Logger', this.logger);

        // Register repositories
        container.registerSingleton('UserRepository', UserRepositoryImpl);
        container.registerSingleton('SessionRepository', SessionRepositoryImpl);
        container.registerSingleton('RBACRepository', RBACRepositoryImpl);

        // Register use cases
        container.registerSingleton(LoginUseCase);
        container.registerSingleton(ValidateTokenUseCase);
    }

    async start(): Promise<void> {
        await this.initialize();

        // Setup delivery methods
        await Promise.all([
            this.setupHttp(),
            // this.setupGraphQL(),
            // this.setupGRPC()
        ]);

        this.setupGracefulShutdown();
    }

    private async setupHttp(): Promise<void> {
        const httpPort = Config.HTTP_PORT;

        this.httpServer.use(express.json());
        setupRoutes(this.httpServer);

        return new Promise((resolve) => {
            const server = this.httpServer.listen(httpPort, () => {
                this.logger.info(`HTTP Server running on port ${httpPort}`);
                resolve();
            });

            // HTTP Graceful shutdown
            process.on('SIGTERM', () => {
                this.logger.info('SIGTERM received. Shutting down HTTP server...');
                server.close(() => {
                    this.logger.info('HTTP server closed');
                });
            });
        });
    }

    private setupGracefulShutdown(): void {
        const shutdown = async () => {
            this.logger.info('Shutting down...');

            try {
                await this.redis.quit();
                await this.dataSource.destroy();
                this.logger.info('Connections closed');
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during shutdown:', error);
                process.exit(1);
            }
        };

        process.on('SIGTERM', shutdown);
        process.on('SIGINT', shutdown);
    }
}
=====================


=====================
auth.handler.ts
src/delivery/http/handlers/auth.handler.ts
=====================
import { Request, Response } from 'express';
import { injectable } from 'tsyringe';
import { LoginUseCase } from '@/usecase/auth/login.usecase';
import { AuthError } from '@/utils/errors';

@injectable()
export class AuthHandler {
    constructor(private loginUseCase: LoginUseCase) {}

    async login(req: Request, res: Response): Promise<void> {
        try {
            const { email, password } = req.body;
            const userAgent = req.headers['user-agent'] || '';
            const ipAddress = req.ip;

            // Get location from headers or set default
            const latitude = req.headers['x-latitude'] as string || '0';
            const longitude = req.headers['x-longitude'] as string || '0';

            const session = await this.loginUseCase.execute({
                email,
                password,
                userAgent,
                ipAddress,
                latitude,
                longitude
            });

            res.status(200).json({
                status: 'success',
                data: {
                    accessToken: session.accessToken,
                    refreshToken: session.refreshToken,
                    expiresIn: session.accessTokenExpiredAt,
                    tokenType: 'Bearer'
                }
            });
        } catch (error) {
            if (error instanceof AuthError) {
                res.status(401).json({
                    status: 'error',
                    message: error.message
                });
                return;
            }

            res.status(500).json({
                status: 'error',
                message: 'Internal server error'
            });
        }
    }
}
=====================


=====================
error.handler.ts
src/delivery/http/middlewares/error.handler.ts
=====================
// src/delivery/http/middlewares/error.handler.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';

export const errorHandler = (
    err: Error,
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.error('Error handling request:', err);

    res.status(500).json({
        status: 'error',
        message: 'Internal server error'
    });
};
=====================


=====================
request.logger.ts
src/delivery/http/middlewares/request.logger.ts
=====================
// src/delivery/http/middlewares/request.logger.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@/utils/logger';

export const requestLogger = (
    req: Request,
    res: Response,
    next: NextFunction
): void => {
    Logger.info(`${req.method} ${req.path}`, {
        body: req.body,
        query: req.query,
        ip: req.ip,
        userAgent: req.headers['user-agent']
    });
    next();
};
=====================


=====================
auth.route.ts
src/delivery/http/routes/auth.route.ts
=====================
// src/delivery/http/routes/auth.route.ts
import { Router } from 'express';
import { container } from 'tsyringe';
import { AuthHandler } from '../handlers/auth.handler';
import { validateLoginRequest } from '../middlewares/validators/auth.validator';

export const authRouter = Router();
const authHandler = container.resolve(AuthHandler);

authRouter.post('/login', validateLoginRequest, (req, res) => authHandler.login(req, res));
=====================


=====================
index.ts
src/delivery/http/routes/index.ts
=====================
// src/delivery/http/routes/index.ts
import { Router } from 'express';
import { authRouter } from './auth.route';
import { errorHandler } from '../middlewares/error.handler';
import { requestLogger } from '../middlewares/request.logger';

export const setupRoutes = (app: Router): void => {
    // Middlewares
    app.use(requestLogger);

    // Routes
    app.use('/api/v1/auth', authRouter);

    // Error Handler
    app.use(errorHandler);
};
=====================


=====================
action.entity.ts
src/domain/entities/action.entity.ts
=====================
// src/domain/entities/action.entity.ts
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('actions')
export class Action {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
resource.entity.ts
src/domain/entities/resource.entity.ts
=====================
import { Entity, PrimaryColumn } from 'typeorm';

@Entity('resources')
export class Resource {
    @PrimaryColumn()
    id!: string;
}
=====================


=====================
roleResourceAction.entity.ts
src/domain/entities/roleResourceAction.entity.ts
=====================
import { Entity, Column, PrimaryColumn, ManyToOne, JoinColumn } from 'typeorm';
import { Role } from '@/utils/constants';
import { Resource } from './resource.entity';
import { Action } from './action.entity';

@Entity('role_resource_actions')
export class RoleResourceAction {
    @PrimaryColumn({
        type: 'enum',
        enum: Role
    })
    role!: Role;

    @PrimaryColumn()
    resource!: string;

    @PrimaryColumn()
    action!: string;

    @ManyToOne(() => Resource)
    @JoinColumn({ name: 'resource' })
    resourceRef!: Resource;

    @ManyToOne(() => Action)
    @JoinColumn({ name: 'action' })
    actionRef!: Action;
}
=====================


=====================
session.entity.ts
src/domain/entities/session.entity.ts
=====================
// src/domain/entities/session.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('sessions')
export class Session {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ name: 'user_id' })
    userId!: number;

    @Column({ name: 'access_token', unique: true })
    accessToken!: string;

    @Column({ name: 'refresh_token', unique: true })
    refreshToken!: string;

    @Column({ name: 'access_token_expired_at' })
    accessTokenExpiredAt!: Date;

    @Column({ name: 'refresh_token_expired_at' })
    refreshTokenExpiredAt!: Date;

    @Column({ name: 'user_agent' })
    userAgent!: string;

    @Column()
    latitude!: string;

    @Column()
    longitude!: string;

    @Column({ name: 'ip_address' })
    ipAddress!: string;

    @CreateDateColumn()
    createdAt!: Date;

    @UpdateDateColumn()
    updatedAt!: Date;

    isAccessTokenExpired(): boolean {
        return new Date() > this.accessTokenExpiredAt;
    }

    static newSessionTokenCacheKey(token: string): string {
        return `cache:id:session_token:${token}`;
    }

    static newSessionTokenCacheKeyByID(id: number): string {
        return `cache:object:session:id:${id}`;
    }
}
=====================


=====================
user.entity.ts
src/domain/entities/user.entity.ts
=====================
// src/domain/entities/user.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Role } from '@/utils/constants';

@Entity('users')
export class User {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ unique: true })
    email!: string;

    @Column()
    password!: string;

    @Column({
        type: 'enum',
        enum: Role,
        default: Role.EMPLOYEE
    })
    role!: Role;

    @Column({ default: true })
    isActive!: boolean;

    @CreateDateColumn()
    createdAt!: Date;

    @UpdateDateColumn()
    updatedAt!: Date;
}
=====================


=====================
rbac.repository.ts
src/domain/repositories/rbac.repository.ts
=====================
// import { Role, Resource, Action } from '@/utils/constants';
// import { RoleResourceAction } from '../entities/role-resource-action.entity';
//
// export interface RBACRepository {
//     createPermission(rra: RoleResourceAction): Promise<void>;
//     hasPermission(role: Role, resource: Resource, action: Action): Promise<boolean>;
//     getRolePermissions(role: Role): Promise<RoleResourceAction[]>;
//     loadPermission(): Promise<{ RRA: Map<Role, Array<{ Resource: Resource; Action: Action }>> }>;
//     initializeDefaultPermissions(): Promise<void>;
// }
//
// // src/domain/repositories/rbac.repository.ts
import { Role } from '@/utils/constants';

export interface Permission {
    RRA: Map<Role, Array<{ resource: string; action: string }>>;
}

export interface RBACRepository {
    createResource(resource: string): Promise<void>;
    createAction(action: string): Promise<void>;
    createRoleResourceAction(role: Role, resource: string, action: string): Promise<void>;
    loadPermission(): Promise<Permission>;
    hasPermission(role: Role, resource: string, action: string): Promise<boolean>;
    initializeDefaultPermissions(): Promise<void>;
}
=====================


=====================
session.repository.ts
src/domain/repositories/session.repository.ts
=====================
import { Session } from '../entities/session.entity';
import { TokenType } from '@/utils/constants';

export interface SessionRepository {
    create(session: Session): Promise<Session>;
    findByToken(tokenType: TokenType, token: string): Promise<Session | null>;
    findById(id: number): Promise<Session | null>;
    findByUserId(userId: number): Promise<Session[]>;
    delete(id: number): Promise<void>;
    deleteByUserId(userId: number): Promise<void>;
}
=====================


=====================
user.repository.ts
src/domain/repositories/user.repository.ts
=====================
import { User } from '../entities/user.entity';

export interface UserRepository {
    create(user: User): Promise<User>;
    findById(id: number): Promise<User | null>;
    findByEmail(email: string): Promise<User | null>;
    update(id: number, user: Partial<User>): Promise<User>;
    delete(id: number): Promise<void>;
}
=====================


=====================
index.ts
src/index.ts
=====================
import 'reflect-metadata';
import { Command } from 'commander';
import { Server } from './console/server';
import { migrateCommand } from './console/migrate';

const program = new Command();

program
    .name('auth-service')
    .description('Authentication Service CLI')
    .version('1.0.0');

// Add migrate command
program.addCommand(migrateCommand);

// Add server command
program
    .command('serve')
    .description('Start the server')
    .action(async () => {
        const server = new Server();
        await server.start();
    });

program.parse();
=====================


=====================
rbac.repository.ts
src/repository/rbac.repository.ts
=====================
// src/repository/rbac.repository.ts
import { injectable } from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import {DEFAULT_ACTIONS, DEFAULT_RESOURCES, Role} from '@/utils/constants';
import { Resource } from '@/domain/entities/resource.entity';
import { Action } from '@/domain/entities/action.entity';
import { RoleResourceAction } from '@/domain/entities/roleResourceAction.entity';
import { RBACRepository, Permission } from '@/domain/repositories/rbac.repository';

@injectable()
export class RBACRepositoryImpl implements RBACRepository {
    private resourceRepo: Repository<Resource>;
    private actionRepo: Repository<Action>;
    private rraRepo: Repository<RoleResourceAction>;
    private RBAC_PERMISSION_CACHE_KEY = 'cache:object:rbac:permission';

    constructor(
        dataSource: DataSource,
        private redis: Redis
    ) {
        this.resourceRepo = dataSource.getRepository(Resource);
        this.actionRepo = dataSource.getRepository(Action);
        this.rraRepo = dataSource.getRepository(RoleResourceAction);
    }

    async createResource(resource: string): Promise<void> {
        const res = new Resource();
        res.id = resource;
        await this.resourceRepo.save(res);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createAction(action: string): Promise<void> {
        const act = new Action();
        act.id = action;
        await this.actionRepo.save(act);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async createRoleResourceAction(role: Role, resource: string, action: string): Promise<void> {
        const rra = new RoleResourceAction();
        rra.role = role;
        rra.resource = resource;
        rra.action = action;
        await this.rraRepo.save(rra);
        await this.redis.del(this.RBAC_PERMISSION_CACHE_KEY);
    }

    async loadPermission(): Promise<Permission> {
        const cachedPermission = await this.redis.get(this.RBAC_PERMISSION_CACHE_KEY);
        if (cachedPermission) {
            return JSON.parse(cachedPermission);
        }

        const permissions = await this.rraRepo.find();
        const permissionMap = new Map<Role, Array<{ resource: string; action: string }>>();

        permissions.forEach(permission => {
            const rolePermissions = permissionMap.get(permission.role) || [];
            rolePermissions.push({
                resource: permission.resource,
                action: permission.action
            });
            permissionMap.set(permission.role, rolePermissions);
        });

        const permission: Permission = {
            RRA: permissionMap
        };

        await this.redis.set(
            this.RBAC_PERMISSION_CACHE_KEY,
            JSON.stringify(permission),
            'EX',
            3600
        );

        return permission;
    }

    async hasPermission(role: Role, resource: string, action: string): Promise<boolean> {
        const permission = await this.loadPermission();
        const rolePermissions = permission.RRA.get(role) || [];

        return rolePermissions.some(
            rra => rra.resource === resource && rra.action === action
        );
    }

    async initializeDefaultPermissions(): Promise<void> {
        // Create default resources
        for (const resource of Object.values(DEFAULT_RESOURCES)) {
            await this.createResource(resource);
        }

        // Create default actions
        for (const action of Object.values(DEFAULT_ACTIONS)) {
            await this.createAction(action);
        }

        // Create default role-resource-actions
        const defaultPermissions = [
            // Admin permissions
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.CREATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.READ },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.UPDATE },
            { role: Role.ADMIN, resource: DEFAULT_RESOURCES.USER, action: DEFAULT_ACTIONS.DELETE },

            // Manager permissions
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.EMPLOYEE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.APPROVE },
            { role: Role.MANAGER, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.REJECT },

            // Employee permissions
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.SUBMIT },
            { role: Role.EMPLOYEE, resource: DEFAULT_RESOURCES.ATTENDANCE, action: DEFAULT_ACTIONS.READ },
        ];

        for (const perm of defaultPermissions) {
            await this.createRoleResourceAction(perm.role, perm.resource, perm.action);
        }
    }
}
=====================


=====================
session.repository.ts
src/repository/session.repository.ts
=====================
// src/repository/session.repository.ts
import { injectable } from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { Redis } from 'ioredis';
import { Session } from '@/domain/entities/session.entity';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { TokenType } from '@/utils/constants';

@injectable()
export class SessionRepositoryImpl implements SessionRepository {
    private repository: Repository<Session>;

    constructor(
        dataSource: DataSource,
        private redis: Redis
    ) {
        this.repository = dataSource.getRepository(Session);
    }

    async create(session: Session): Promise<Session> {
        const savedSession = await this.repository.save(session);
        await this.cacheSession(savedSession);
        return savedSession;
    }

    async findByToken(tokenType: TokenType, token: string): Promise<Session | null> {
        const cacheKey = Session.newSessionTokenCacheKey(token);
        const cachedSession = await this.redis.get(cacheKey);

        if (cachedSession) {
            return JSON.parse(cachedSession);
        }

        const session = await this.repository.findOne({
            where: tokenType === TokenType.ACCESS_TOKEN
                ? { accessToken: token }
                : { refreshToken: token }
        });

        if (session) {
            await this.cacheSession(session);
        }

        return session;
    }

    private async cacheSession(session: Session): Promise<void> {
        const cacheKey = Session.newSessionTokenCacheKey(session.accessToken);
        await this.redis.set(cacheKey, JSON.stringify(session), 'EX', 3600); // 1 hour
    }

    delete(id: number): Promise<void> {
        return Promise.resolve(undefined);
    }

    deleteByUserId(userId: number): Promise<void> {
        return Promise.resolve(undefined);
    }

    async findById(id: number): Promise<Session | null> {
        const cacheKey = Session.newSessionTokenCacheKeyByID(id);
        const cachedSession = await this.redis.get(cacheKey);

        if (cachedSession) {
            return JSON.parse(cachedSession);
        }

        const session = await this.repository.findOne({
            where: {id : id}
        });

        if (session) {
            await this.cacheSession(session);
        }

        return session;
    }

    findByUserId(userId: number): Promise<Session[]> {
        return Promise.resolve([]);
    }

}
=====================


=====================
user.repository.ts
src/repository/user.repository.ts
=====================
import { injectable } from 'tsyringe';
import { Repository, DataSource } from 'typeorm';
import { User } from '@/domain/entities/user.entity';
import { UserRepository } from '@/domain/repositories/user.repository';

@injectable()
export class UserRepositoryImpl implements UserRepository {
    private repository: Repository<User>;

    constructor(dataSource: DataSource) {
        this.repository = dataSource.getRepository(User);
    }

    async create(user: User): Promise<User> {
        return await this.repository.save(user);
    }

    async findById(id: number): Promise<User | null> {
        return await this.repository.findOneBy({ id });
    }

    async findByEmail(email: string): Promise<User | null> {
        return await this.repository.findOneBy({ email });
    }

    async update(id: number, userData: Partial<User>): Promise<User> {
        await this.repository.update(id, userData);
        return (await this.findById(id))!;
    }

    async delete(id: number): Promise<void> {
        await this.repository.delete(id);
    }
}
=====================


=====================
login.usecase.ts
src/usecase/auth/login.usecase.ts
=====================
import { injectable } from 'tsyringe';
import { compare } from 'bcrypt';
import { UserRepository } from '@/domain/repositories/user.repository';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { Session } from '@/domain/entities/session.entity';
import { generateToken } from '@/utils/token';
import { AuthError } from '@/utils/errors';

interface LoginDTO {
    email: string;
    password: string;
    userAgent: string;
    ipAddress: string;
    latitude: string;
    longitude: string;
}

@injectable()
export class LoginUseCase {
    constructor(
        private userRepository: UserRepository,
        private sessionRepository: SessionRepository
    ) {}

    async execute(data: LoginDTO): Promise<Session> {
        const user = await this.userRepository.findByEmail(data.email);
        if (!user) {
            throw new AuthError('Invalid credentials');
        }

        const isValidPassword = await compare(data.password, user.password);
        if (!isValidPassword) {
            throw new AuthError('Invalid credentials');
        }

        if (!user.isActive) {
            throw new AuthError('User is inactive');
        }

        const session = new Session();
        session.userId = user.id;
        session.accessToken = generateToken();
        session.refreshToken = generateToken();
        session.accessTokenExpiredAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
        session.refreshTokenExpiredAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
        session.userAgent = data.userAgent;
        session.ipAddress = data.ipAddress;
        session.latitude = data.latitude;
        session.longitude = data.longitude;

        return await this.sessionRepository.create(session);
    }
}
=====================


=====================
validate-token.usecase.ts
src/usecase/auth/validate-token.usecase.ts
=====================
// src/usecase/auth/validate-token.usecase.ts
import { injectable } from 'tsyringe';
import { SessionRepository } from '@/domain/repositories/session.repository';
import { UserRepository } from '@/domain/repositories/user.repository';
import { RBACRepository } from '@/domain/repositories/rbac.repository';
import { TokenType, Resource, Action } from '@/utils/constants';
import { AuthError } from '@/utils/errors';

interface ValidateTokenResponse {
    userId: number;
    role: string;
    permissions: string[];
}

@injectable()
export class ValidateTokenUseCase {
    constructor(
        private sessionRepository: SessionRepository,
        private userRepository: UserRepository,
        private rbacRepository: RBACRepository
    ) {}

    async execute(token: string): Promise<ValidateTokenResponse> {
        const session = await this.sessionRepository.findByToken(TokenType.ACCESS_TOKEN, token);
        if (!session || session.isAccessTokenExpired()) {
            throw new AuthError('Invalid or expired token');
        }

        const user = await this.userRepository.findById(session.userId);
        if (!user || !user.isActive) {
            throw new AuthError('User not found or inactive');
        }

        const permissions = await this.rbacRepository.getRolePermissions(user.role);

        return {
            userId: user.id,
            role: user.role,
            permissions: permissions.map(p => `${p.resource}:${p.action}`)
        };
    }
}
=====================


=====================
constants.ts
src/utils/constants.ts
=====================
// src/utils/constants.ts
export enum Role {
    ADMIN = 'ADMIN',
    MANAGER = 'MANAGER',
    EMPLOYEE = 'EMPLOYEE'
}

export const DEFAULT_RESOURCES = {
    USER: 'user',
    EMPLOYEE: 'employee',
    ATTENDANCE: 'attendance',
    SESSION: 'session',
    REPORT: 'report'
} as const;

export const DEFAULT_ACTIONS = {
    CREATE: 'create',
    READ: 'read',
    UPDATE: 'update',
    DELETE: 'delete',
    APPROVE: 'approve',
    REJECT: 'reject',
    SUBMIT: 'submit'
} as const;

export enum TokenType {
    ACCESS_TOKEN = 0,
    REFRESH_TOKEN = 1
}
=====================


=====================
defaultPermissions.ts
src/utils/defaultPermissions.ts
=====================
import { Role, Resource, Action } from './constants';

export const defaultPermissions = [
    // Admin permissions
    { role: Role.ADMIN, resource: Resource.USER, action: Action.CREATE },
    { role: Role.ADMIN, resource: Resource.USER, action: Action.READ },
    { role: Role.ADMIN, resource: Resource.USER, action: Action.UPDATE },
    { role: Role.ADMIN, resource: Resource.USER, action: Action.DELETE },
    { role: Role.ADMIN, resource: Resource.EMPLOYEE, action: Action.CREATE },
    { role: Role.ADMIN, resource: Resource.EMPLOYEE, action: Action.READ },
    { role: Role.ADMIN, resource: Resource.EMPLOYEE, action: Action.UPDATE },
    { role: Role.ADMIN, resource: Resource.EMPLOYEE, action: Action.DELETE },
    { role: Role.ADMIN, resource: Resource.ATTENDANCE, action: Action.READ },
    { role: Role.ADMIN, resource: Resource.REPORT, action: Action.READ },

    // Manager permissions
    { role: Role.MANAGER, resource: Resource.EMPLOYEE, action: Action.READ },
    { role: Role.MANAGER, resource: Resource.ATTENDANCE, action: Action.READ },
    { role: Role.MANAGER, resource: Resource.ATTENDANCE, action: Action.APPROVE },
    { role: Role.MANAGER, resource: Resource.ATTENDANCE, action: Action.REJECT },
    { role: Role.MANAGER, resource: Resource.REPORT, action: Action.READ },

    // Employee permissions
    { role: Role.EMPLOYEE, resource: Resource.ATTENDANCE, action: Action.SUBMIT },
    { role: Role.EMPLOYEE, resource: Resource.ATTENDANCE, action: Action.READ },
];
=====================


=====================
errors.ts
src/utils/errors.ts
=====================
export class AuthError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'AuthError';
    }
}

export class PermissionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'PermissionError';
    }
}
=====================


=====================
token.ts
src/utils/token.ts
=====================
// src/utils/token.ts
import { randomBytes } from 'crypto';

export function generateToken(length: number = 32): string {
    return randomBytes(length).toString('hex');
}
=====================
